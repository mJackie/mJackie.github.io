<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Jackie Liu&#39;s Blog</title>
  <subtitle>Just so so</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://mjackie.github.io/"/>
  <updated>2018-03-14T16:10:47.316Z</updated>
  <id>http://mjackie.github.io/</id>
  
  <author>
    <name>Jackie Liu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>实习面试</title>
    <link href="http://mjackie.github.io/Life/cjera9vgi002behs6s3zlmaku/"/>
    <id>http://mjackie.github.io/Life/cjera9vgi002behs6s3zlmaku/</id>
    <published>2018-03-14T16:09:00.000Z</published>
    <updated>2018-03-14T16:10:47.316Z</updated>
    
    <content type="html"><![CDATA[<p>过完年回来开始准备找实习，才发现自己把寒假的时间都浪费了，什么事情都没有干。本来打算寒假准备一下，到北京直接开始面试的，没想到计划赶不上变化。分析原因可能来自两方面，一是作为研一新生，在家和校园里还没有感受到现实与工作的压力；二是自己本身自控能力就差吧，这也是老毛病了。</p>
<p>终于还是到了北京，在双坤租的房子里待了将近一个星期。忽然到一个陌生的环境，让自己很不自在，也感受到了强烈的现实压迫感，好像忽然就要毕业了一样，每过一天，都像是自己失去了许多原本拥有的东西。不过这样也好，人无远虑，必有近忧，提早感受一下毕业找工作的压力，总比天天颓废堕落好了许多。</p>
<p>急急忙忙写完了选修课的作业，花了一天时间做了份简历，开始在实习僧和拉勾网上投简历，也逐渐收到了各个公司HR打来的电话。主要投的就是机器学习算法岗，但其实自己是没有什么机器学习相关实际项目经验的，这也是我一直心虚的地方。</p>
<a id="more"></a>
<h4 id="美团点评"><a href="#美团点评" class="headerlink" title="美团点评"></a>美团点评</h4><p>第一家面试的公司是美团点评，这也是自己第一次参与企业面试，难免有些紧张。</p>
<h5 id="一面"><a href="#一面" class="headerlink" title="一面"></a>一面</h5><ul>
<li>简单自我介绍</li>
<li>tf-idf是什么？（自己简历项目里有写到用tf-idf生成向量空间模型）</li>
<li>SVM与LR区别与联系，什么时候用SVM，什么时候LR</li>
<li>precesion,recall,accuracy各个指标含义</li>
<li>介绍一个你熟悉的机器学习模型</li>
<li>手写代码，两个有序数组，找第k大的数</li>
</ul>
<h5 id="二面"><a href="#二面" class="headerlink" title="二面"></a>二面</h5><ul>
<li>tf-idf是什么？（又问了我一遍，又说错了。。。）</li>
<li>pca和svd区别</li>
<li>怎么特征提取，特征选择？</li>
<li>python numpy包熟吗？</li>
<li>手写代码，计算idf值</li>
</ul>
<pre><code>Input: List&lt;Doc&gt; list
Output: Map&lt;String, Int&gt; idf
</code></pre><h5 id="经验"><a href="#经验" class="headerlink" title="经验"></a>经验</h5><p>二面没过，面试官说要在几个候选人中筛选一下。总结起来，主要是自己没有准备，机器学习相关知识太薄弱，第一次手写代码也太乱了，没有将简历上的项目捋一遍。</p>
<h4 id="网易传媒"><a href="#网易传媒" class="headerlink" title="网易传媒"></a>网易传媒</h4><h5 id="一面-1"><a href="#一面-1" class="headerlink" title="一面"></a>一面</h5><ul>
<li>precesion,recall,accuracy各个指标含义</li>
<li>是什时候用到F-score,为什么要用F-score</li>
<li>逻辑回归推导</li>
<li>手写代码，找中位数</li>
</ul>
<h4 id="二面-1"><a href="#二面-1" class="headerlink" title="二面"></a>二面</h4><ul>
<li>Hadoop,Spark熟吗？介绍下Map-Reduce</li>
<li>逻辑回归，为什么是ln，而不是log2或log3</li>
<li>手写代码，二分查找，递归与非递归形式</li>
</ul>
<h4 id="经验-1"><a href="#经验-1" class="headerlink" title="经验"></a>经验</h4><p>吸取了美团面试的经验，开学在图书馆猛看了两天书，把逻辑回归，SVM相关内容过了一遍。面试状态很好，二面完后leader带我体验了下网易的食堂，开始和我聊学校的事情，leader人很好，让我等候hr后续的通知。</p>
<h4 id="搜狐大数据中心"><a href="#搜狐大数据中心" class="headerlink" title="搜狐大数据中心"></a>搜狐大数据中心</h4><h5 id="一面-2"><a href="#一面-2" class="headerlink" title="一面"></a>一面</h5><ul>
<li>介绍下pca</li>
<li>介绍下java中hashmap底层实现</li>
<li>介绍下svm</li>
<li>svm核函数需要满足的条件</li>
<li>画了个表，让写条sql语句</li>
<li>Hadoop,Spark了解吗？</li>
<li>手写代码，两个有序数组，找中位数</li>
</ul>
<h4 id="经验-2"><a href="#经验-2" class="headerlink" title="经验"></a>经验</h4><p>搜狐连二面的机会都没有给，主要是手写代码时自己把问题看错了，以为是无序数组，和面试官完全不在一个频道上交流。另外一个原因可能是感觉网易基本可以了，自己就松懈了。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>机器学习算法岗面试主要考察的内容可以分为三部分吧：</p>
<ul>
<li>项目（会问的很细，最好面试前把项目过一遍，并且准备好一套应对提问的说辞）</li>
<li>机器学习相关知识（LR，SVM，过拟合，pca，正则项，评价指标，特征选择等）</li>
<li>编程题（很简单，基本都是数组，字符串之类的，DP,网络流这类的根本就不会考）</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;过完年回来开始准备找实习，才发现自己把寒假的时间都浪费了，什么事情都没有干。本来打算寒假准备一下，到北京直接开始面试的，没想到计划赶不上变化。分析原因可能来自两方面，一是作为研一新生，在家和校园里还没有感受到现实与工作的压力；二是自己本身自控能力就差吧，这也是老毛病了。&lt;/p&gt;
&lt;p&gt;终于还是到了北京，在双坤租的房子里待了将近一个星期。忽然到一个陌生的环境，让自己很不自在，也感受到了强烈的现实压迫感，好像忽然就要毕业了一样，每过一天，都像是自己失去了许多原本拥有的东西。不过这样也好，人无远虑，必有近忧，提早感受一下毕业找工作的压力，总比天天颓废堕落好了许多。&lt;/p&gt;
&lt;p&gt;急急忙忙写完了选修课的作业，花了一天时间做了份简历，开始在实习僧和拉勾网上投简历，也逐渐收到了各个公司HR打来的电话。主要投的就是机器学习算法岗，但其实自己是没有什么机器学习相关实际项目经验的，这也是我一直心虚的地方。&lt;/p&gt;
    
    </summary>
    
      <category term="Life" scheme="http://mjackie.github.io/categories/Life/"/>
    
    
      <category term="算法, 机器学习" scheme="http://mjackie.github.io/tags/%E7%AE%97%E6%B3%95-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>算法课程笔记</title>
    <link href="http://mjackie.github.io/Tech/cjera9vgr0035ehs6fsfq80b9/"/>
    <id>http://mjackie.github.io/Tech/cjera9vgr0035ehs6fsfq80b9/</id>
    <published>2018-01-29T18:47:00.000Z</published>
    <updated>2018-02-23T18:49:33.239Z</updated>
    
    <content type="html"><![CDATA[<h3 id="分治"><a href="#分治" class="headerlink" title="分治"></a>分治</h3><p>分治问题复杂度计算</p>
<h3 id=""><a href="#" class="headerlink" title=""></a><img src="/post_image/algo-note/DC.jpeg" alt="DC"></h3><a id="more"></a>
<h3 id="网络流"><a href="#网络流" class="headerlink" title="网络流"></a>网络流</h3><h4 id="最短路径算法复杂度"><a href="#最短路径算法复杂度" class="headerlink" title="最短路径算法复杂度"></a>最短路径算法复杂度</h4><ul>
<li>Dijkstra：O(n2)适用于权值为非负的图的单源最短路径，用斐波那契堆的复杂度O(E+VlgV)</li>
</ul>
<ul>
<li>BellmanFord：适用于权值有负值的图的单源最短路径，并且能够检测负圈，复杂度O(VE)</li>
</ul>
<ul>
<li>SPFA：适用于权值有负值，且没有负圈的图的单源最短路径，论文中的复杂度O(kE)，k为每个节点进入Queue的次数，且k一般&lt;=2，但此处的复杂度证明是有问题的，其实SPFA的最坏情况应该是O(VE).</li>
</ul>
<ul>
<li>Floyd：每对节点之间的最短路径。Floyd-Warshall算法的时间复杂度为O(N3)，空间复杂度为O(N2)</li>
</ul>
<h4 id="最大流算法复杂度"><a href="#最大流算法复杂度" class="headerlink" title="最大流算法复杂度"></a>最大流算法复杂度</h4><p>n表示节点数，m表示边数</p>
<h4 id="-1"><a href="#-1" class="headerlink" title=""></a><img src="/post_image/algo-note/MaxFlow.jpeg" alt="MaxFlow"></h4><h3 id="NPC问题"><a href="#NPC问题" class="headerlink" title="NPC问题"></a>NPC问题</h3><p><strong>证明一个问题是 NPC问题。先证明它至少是一个NP问题，再证明其中一个已知的NPC问题能约化到它，这样就可以说它是NPC问题了</strong></p>
<h4 id="问题分类"><a href="#问题分类" class="headerlink" title="问题分类"></a>问题分类</h4><p><img src="/post_image/algo-note/p-np-npc-nphard.jpeg" alt="p-np-npc-nphard"></p>
<ul>
<li>P: <strong>能在多项式时间内解决的问题</strong></li>
</ul>
<ul>
<li>NP: 不能在多项式时间内解决或不确定能不能在多项式时间内解决，但<strong>能在多项式时间验证的问题</strong></li>
</ul>
<ul>
<li>NPC: NP完全问题，<strong>所有NP问题在多项式时间内都能约化(Reducibility)到它的NP问题</strong>，即解决了此NPC问题，所有NP问题也都得到解决</li>
</ul>
<ul>
<li>NP hard:NP难问题，<strong>所有NP问题在多项式时间内都能约化(Reducibility)到它的问题(不一定是NP问题)</strong></li>
</ul>
<h4 id="问题难度"><a href="#问题难度" class="headerlink" title="问题难度"></a>问题难度</h4><p><img src="/post_image/algo-note/problem.jpeg" alt="problem"></p>
<h4 id="Independent-Set-Problem"><a href="#Independent-Set-Problem" class="headerlink" title="Independent Set Problem"></a>Independent Set Problem</h4><p>Suppose you have n friends, and some pairs of them don’t get along. How to invite at least k of them to dinner if you don’t want any interpersonal tension?</p>
<blockquote>
<p>Input: Given a graph G =&lt; V, E &gt;, and an integer k,</p>
<p>Output: is there a set of nodes S⊆V, |S|=k , such that no two nodes in S are joined by an edge?</p>
</blockquote>
<p><img src="/post_image/algo-note/isp.jpeg" alt="isp"></p>
<p>The three nodes in blue are independent.</p>
<h4 id="Vertex-Cover-Problem"><a href="#Vertex-Cover-Problem" class="headerlink" title="Vertex Cover Problem"></a>Vertex Cover Problem</h4><p>Given n sites connected with paths, how many guards (or</p>
<p>cameras) should be deployed on sites to surveille all the paths?</p>
<blockquote>
<p>Input: Given a graph G =&lt; V, E &gt;, and an integer k,</p>
<p>Output: is there a set of nodes S ⊆ V, |S| = k, such that eachedge has at least one of its endpoints in S?</p>
</blockquote>
<p><img src="/post_image/algo-note/vcp.jpeg" alt="vcp"></p>
<p>the complement of an independent set (in blue) forms a vertex cover (in red)</p>
<h4 id="SAT-Satisfiability-Problem"><a href="#SAT-Satisfiability-Problem" class="headerlink" title="SAT (Satisfiability) Problem"></a>SAT (Satisfiability) Problem</h4><p>expressing constraints on a set of variables (in AI), verifying whether a circuit has the desired functionality (in VLSI), etc.</p>
<blockquote>
<p>Input: Given a CNF φ = C1 ∧C2…∧Ck;</p>
<p>Output: Is there an assignment of all xi such that all clauses Cj.are satisfied?</p>
<p>Example:</p>
<p>CNF: (x1 ∨¬x2)∧(¬x1 ∨¬x3)∧(x2 ∨¬x3)</p>
<p>TRUE assignment: x1 = FALSE, x2 = FALSE, x3 = FALSE;</p>
</blockquote>
<h4 id="3SAT-Problem"><a href="#3SAT-Problem" class="headerlink" title="3SAT  Problem"></a>3SAT  Problem</h4><p>每个 Ci 含有三个变量</p>
<h4 id="Hamilton-Cycle-Problem"><a href="#Hamilton-Cycle-Problem" class="headerlink" title="Hamilton Cycle Problem"></a>Hamilton Cycle Problem</h4><blockquote>
<p>Input: Given a graph G =&lt; V, E &gt;</p>
<p>Output: Is there a cycle visiting every node exactly once?</p>
</blockquote>
<h4 id="3-Coloring"><a href="#3-Coloring" class="headerlink" title="3 Coloring"></a>3 Coloring</h4><blockquote>
<p>Output: Is there a k−coloring of G such that each node has a color, but the two endpoints of an edge have different colors?</p>
</blockquote>
<p><img src="/post_image/algo-note/3color.jpeg" alt="3color"></p>
<h4 id="SubsetSum-problem"><a href="#SubsetSum-problem" class="headerlink" title="SubsetSum problem"></a>SubsetSum problem</h4><blockquote>
<p>Input: Given n numbers S = w1, w2, …, wn, and an objective value W;</p>
<p>Output: is there a subset S′ ⊆ S such that the sum of S′ is W?</p>
</blockquote>
<h4 id="Clique-problem"><a href="#Clique-problem" class="headerlink" title="Clique problem"></a>Clique problem</h4><blockquote>
<p> Input: Graph G =&lt; V, E &gt;, an integer k; </p>
<p> Output: is there a clique of size k? Here, a clique refers to a subset of vertices that are all connected.</p>
</blockquote>
<h3 id="线性规划"><a href="#线性规划" class="headerlink" title="线性规划"></a>线性规划</h3><h4 id="原始问题"><a href="#原始问题" class="headerlink" title="原始问题"></a>原始问题</h4><p><img src="/post_image/algo-note/original.jpeg" alt="original"></p>
<h4 id="对偶问题"><a href="#对偶问题" class="headerlink" title="对偶问题"></a>对偶问题</h4><p><img src="/post_image/algo-note/dual.jpeg" alt="dual"></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;分治&quot;&gt;&lt;a href=&quot;#分治&quot; class=&quot;headerlink&quot; title=&quot;分治&quot;&gt;&lt;/a&gt;分治&lt;/h3&gt;&lt;p&gt;分治问题复杂度计算&lt;/p&gt;
&lt;h3 id=&quot;&quot;&gt;&lt;a href=&quot;#&quot; class=&quot;headerlink&quot; title=&quot;&quot;&gt;&lt;/a&gt;&lt;img src=&quot;/post_image/algo-note/DC.jpeg&quot; alt=&quot;DC&quot;&gt;&lt;/h3&gt;
    
    </summary>
    
      <category term="Tech" scheme="http://mjackie.github.io/categories/Tech/"/>
    
    
      <category term="算法" scheme="http://mjackie.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>卜东波算法课程作业</title>
    <link href="http://mjackie.github.io/Tech/cjera9vgl002lehs6bqkyhz73/"/>
    <id>http://mjackie.github.io/Tech/cjera9vgl002lehs6bqkyhz73/</id>
    <published>2018-01-24T02:50:00.000Z</published>
    <updated>2018-02-22T14:22:59.931Z</updated>
    
    <content type="html"><![CDATA[<p>本学期的算法课程作业，一共6次，用LaTex完成。卜老师的算法课深入浅出，本学期的所有课程都由卜老师亲自授课，课程内容不仅包含面试中常见的分治、动规、贪心等方法，还详细介绍了线性规划、网络流、NP问题等内容。非常高质量密度的一门课，感谢卜东波老师。</p>
<p><img src="/post_image/bdb-assign-answer/a_1.jpeg" alt="image"></p>
<a id="more"></a>
<p><img src="/post_image/bdb-assign-answer/a_2.jpeg" alt="image"></p>
<p><img src="/post_image/bdb-assign-answer/a_3.jpeg" alt="image"></p>
<p><img src="/post_image/bdb-assign-answer/a_4.jpeg" alt="image"></p>
<p><img src="/post_image/bdb-assign-answer/a_5.jpeg" alt="image"></p>
<p><img src="/post_image/bdb-assign-answer/a_6.jpeg" alt="image"></p>
<p><img src="/post_image/bdb-assign-answer/a_7.jpeg" alt="image"></p>
<p><img src="/post_image/bdb-assign-answer/a_8.jpeg" alt="image"></p>
<p><img src="/post_image/bdb-assign-answer/a_9.jpeg" alt="image"></p>
<p><img src="/post_image/bdb-assign-answer/a_10.jpeg" alt="image"></p>
<p><img src="/post_image/bdb-assign-answer/a_11.jpeg" alt="image"></p>
<p><img src="/post_image/bdb-assign-answer/a_12.jpeg" alt="image"></p>
<p><img src="/post_image/bdb-assign-answer/a_13.jpeg" alt="image"></p>
<p><img src="/post_image/bdb-assign-answer/a_14.jpeg" alt="image"></p>
<p><img src="/post_image/bdb-assign-answer/a_15.jpeg" alt="image"></p>
<p><img src="/post_image/bdb-assign-answer/a_16.jpeg" alt="image"></p>
<p><img src="/post_image/bdb-assign-answer/a_17.jpeg" alt="image"></p>
<p><img src="/post_image/bdb-assign-answer/a_18.jpeg" alt="image"></p>
<p><img src="/post_image/bdb-assign-answer/a_19.jpeg" alt="image"></p>
<p><img src="/post_image/bdb-assign-answer/a_20.jpeg" alt="image"></p>
<p><img src="/post_image/bdb-assign-answer/a_21.jpeg" alt="image"></p>
<p><img src="/post_image/bdb-assign-answer/a_22.jpeg" alt="image"></p>
<p><img src="/post_image/bdb-assign-answer/a_23.jpeg" alt="image"></p>
<p><img src="/post_image/bdb-assign-answer/a_24.jpeg" alt="image"></p>
<p><img src="/post_image/bdb-assign-answer/a_25.jpeg" alt="image"></p>
<p><img src="/post_image/bdb-assign-answer/a_26.jpeg" alt="image"></p>
<p><img src="/post_image/bdb-assign-answer/a_27.jpeg" alt="image"></p>
<p><img src="/post_image/bdb-assign-answer/a_28.jpeg" alt="image"></p>
<p><img src="/post_image/bdb-assign-answer/a_29.jpeg" alt="image"></p>
<p><img src="/post_image/bdb-assign-answer/a_30.jpeg" alt="image"></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本学期的算法课程作业，一共6次，用LaTex完成。卜老师的算法课深入浅出，本学期的所有课程都由卜老师亲自授课，课程内容不仅包含面试中常见的分治、动规、贪心等方法，还详细介绍了线性规划、网络流、NP问题等内容。非常高质量密度的一门课，感谢卜东波老师。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/post_image/bdb-assign-answer/a_1.jpeg&quot; alt=&quot;image&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Tech" scheme="http://mjackie.github.io/categories/Tech/"/>
    
    
      <category term="算法" scheme="http://mjackie.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="latex" scheme="http://mjackie.github.io/tags/latex/"/>
    
  </entry>
  
  <entry>
    <title>基于Lucene、Servlet新闻搜索引擎</title>
    <link href="http://mjackie.github.io/Tech/cjera9vfk0007ehs6yxuscp9u/"/>
    <id>http://mjackie.github.io/Tech/cjera9vfk0007ehs6yxuscp9u/</id>
    <published>2018-01-06T12:50:00.000Z</published>
    <updated>2018-02-23T18:43:12.027Z</updated>
    
    <content type="html"><![CDATA[<p>GitHub地址：<a href="https://github.com/mJackie/LTY-Search" target="_blank" rel="external">https://github.com/mJackie/LTY-Search</a><br>详细文档参见 <a href="https://github.com/mJackie/LTY-Search/blob/master/%E8%AE%BE%E8%AE%A1%E6%96%87%E6%A1%A3.pdf" target="_blank" rel="external">设计文档</a><br><img src="/post_image/LTY-Search/index.png" alt="image"></p>
<a id="more"></a>
<p><img src="/post_image/LTY-Search/result.png" alt="image"></p>
<h4 id="作业要求"><a href="#作业要求" class="headerlink" title="作业要求"></a>作业要求</h4><p>(1-7个选课学生组成1队)，完成以下任务(12月份末考查)：</p>
<p>新闻及评论搜索：定向采集不少于4个中文社会新闻网站或频道，实现这些网站新闻信息及评论信息的自动爬取、抽取、索引和检索。</p>
<ol>
<li>新闻网页数目不少于10万页。每个新闻网页及其评论能在1天内更新。</li>
<li>支持关键词检索及通配符检索。检索时间平均不超过2秒。</li>
<li>能按相关度、时间、热度(需要自己定义)等属性对检索结果进行排序。能对评论的贬褒进行分析。</li>
<li>具备查询自动补齐、相关搜索推荐、snippet生成、结果预览(鼠标移到相关结果，能预览)等功能。</li>
<li>每条检索结果下面可以对相似新闻进行查找。</li>
<li>首页中列举当前最热的社会新闻。</li>
</ol>
<h4 id="演示地址"><a href="#演示地址" class="headerlink" title="演示地址"></a>演示地址</h4><p><a href="http://47.95.248.80:8089/Search/index" target="_blank" rel="external">http://47.95.248.80:8089/Search/index</a></p>
<h4 id="技术"><a href="#技术" class="headerlink" title="技术"></a>技术</h4><ul>
<li>爬虫:<code>Python</code> , <code>Scrapy</code> </li>
<li>后端:  <code>Lucene</code>,<code>JAVA Servlet</code> </li>
<li>前端: <code>Bootstrap</code> <code>,JQuery</code></li>
<li>服务器: <code>Tomact</code></li>
</ul>
<h4 id="实现功能"><a href="#实现功能" class="headerlink" title="实现功能"></a>实现功能</h4><ul>
<li>新闻网页数目不少于10万页</li>
<li>支持关键词检索及通配符检索。检索时间平均不超过2秒</li>
<li>能按相关度、时间、热度(需要自己定义)等属性对检索结果进行排序</li>
<li>具备snippet生成、结果预览(鼠标点击新闻标题，能预览)等功能</li>
<li>每条检索结果下面可以对相似新闻进行查找</li>
<li>首页中列举当前最热的社会新闻</li>
</ul>
<h4 id="创新点"><a href="#创新点" class="headerlink" title="创新点"></a>创新点</h4><ul>
<li>垂直检索（分类检索，可以只检索对应网站、栏目的新闻内容）</li>
<li>三种检索方式（全文检索、按标题检索、按内容检索）</li>
<li>响应式布局</li>
<li>检索结果首图展示（检索结果页显示该新闻中的首张图片）</li>
<li>关键词高亮（关键字标红显示）</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;GitHub地址：&lt;a href=&quot;https://github.com/mJackie/LTY-Search&quot;&gt;https://github.com/mJackie/LTY-Search&lt;/a&gt;&lt;br&gt;详细文档参见 &lt;a href=&quot;https://github.com/mJackie/LTY-Search/blob/master/%E8%AE%BE%E8%AE%A1%E6%96%87%E6%A1%A3.pdf&quot;&gt;设计文档&lt;/a&gt;&lt;br&gt;&lt;img src=&quot;/post_image/LTY-Search/index.png&quot; alt=&quot;image&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Tech" scheme="http://mjackie.github.io/categories/Tech/"/>
    
    
      <category term="lucene" scheme="http://mjackie.github.io/tags/lucene/"/>
    
      <category term="servlet" scheme="http://mjackie.github.io/tags/servlet/"/>
    
  </entry>
  
  <entry>
    <title>垃圾短信识别系统</title>
    <link href="http://mjackie.github.io/Tech/cjera9vfv000tehs6sykg34v5/"/>
    <id>http://mjackie.github.io/Tech/cjera9vfv000tehs6sykg34v5/</id>
    <published>2017-12-31T02:50:00.000Z</published>
    <updated>2018-02-23T18:42:51.493Z</updated>
    
    <content type="html"><![CDATA[<p>GitHub地址：<a href="https://github.com/mJackie/SpamMessage" target="_blank" rel="external">https://github.com/mJackie/SpamMessage</a><br>实现一个垃圾短信识别系统，在给定的数据集上验证效果.<br><img src="/post_image/SpamMessage/index.jpeg" alt="image"></p>
<a id="more"></a>
<p><img src="/post_image/SpamMessage/result.jpeg" alt="image"></p>
<h4 id="短信数据"><a href="#短信数据" class="headerlink" title="短信数据"></a>短信数据</h4><ul>
<li>标签域: 1表示垃圾短信/0表示正常短信</li>
<li>文本域: 短信源文本(进行了一些处理)</li>
</ul>
<h4 id="分类算法"><a href="#分类算法" class="headerlink" title="分类算法"></a>分类算法</h4><ul>
<li>KNN: K最近邻</li>
<li>LR: 逻辑回归</li>
<li>RF: 随机森林</li>
<li>DT: 决策树</li>
<li>GBDT: 梯度提升决策树</li>
<li>SVM: 支持向量机</li>
<li>MultinomialNB: 多项式分布朴素贝叶斯</li>
<li>BernoulliNB:  伯努利分布朴素贝叶斯</li>
</ul>
<h4 id="环境依赖"><a href="#环境依赖" class="headerlink" title="环境依赖"></a>环境依赖</h4><ul>
<li>Classfier（模型训练）<ul>
<li><a href="https://www.python.org/downloads/" target="_blank" rel="external">Python 2.7.x</a></li>
<li><a href="http://scikit-learn.org/stable/documentation.html#" target="_blank" rel="external">Scikit-learn</a></li>
<li><a href="https://github.com/fxsjy/jieba" target="_blank" rel="external">jieba</a> （已集成至项目内，无需安装）</li>
</ul>
</li>
<li>Sites (演示Demo)<ul>
<li><a href="http://php.net/" target="_blank" rel="external">Apache + PHP</a></li>
<li><a href="https://www.python.org/downloads/" target="_blank" rel="external">Python 2.7.x</a></li>
</ul>
</li>
</ul>
<h4 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h4><pre><code>.
├──Classfier（模型训练）
│  ├── DataProcess(数据预处理)
│  │   ├── jieba(结巴分词库)
│  │   ├── DataPreprocess.py(数据预处理)
│  │   └── message.txt(训练数据)
│  │
│  └── Classifiers.py(分类器)
│ 
├── Sites (演示Demo)
│   ├── Model
│   │   ├── jieba(结巴分词库)
│   │   ├── all_raw(结巴分词库)
│   │   │   ├── model(训练出的模型)
│   │   │   └── vec_tfidf(训练阶段生成的词向量)  
│   │   │
│   │   └── demoAPI.py(demo调用Python接口)
│   │
│   ├── index.php(主页)
│   └── result.php(结果显示页面)
│
└── README.md
</code></pre><h4 id="使用说明"><a href="#使用说明" class="headerlink" title="使用说明"></a>使用说明</h4><h5 id="首先对数据进行预处理，命令如下："><a href="#首先对数据进行预处理，命令如下：" class="headerlink" title="首先对数据进行预处理，命令如下："></a>首先对数据进行预处理，命令如下：</h5><pre><code>$ cd Classfier/DataProcess
$ python DataPreprocess.py
</code></pre><blockquote>
<p>DataPreprocess.py 中主要参数变量含义如下：</p>
<ul>
<li>n_components: 降维到n_components维</li>
<li>data_lines: 预处理的短信条数</li>
<li>data_type: 预处理类型 <code>{raw, pca, nmf, pca&amp;nmf}</code></li>
</ul>
</blockquote>
<h5 id="训练分类器，命令如下："><a href="#训练分类器，命令如下：" class="headerlink" title="训练分类器，命令如下："></a>训练分类器，命令如下：</h5><pre><code>$ cd ..
$ python Classifiers.py
</code></pre><blockquote>
<p>注意修改代码中相关路径，Classifiers.py 中主要参数变量含义如下：</p>
<ul>
<li>takeup: 测试数据占总数据的比例</li>
</ul>
</blockquote>
<h5 id="配置演示Demo"><a href="#配置演示Demo" class="headerlink" title="配置演示Demo"></a>配置演示Demo</h5><ol>
<li>将数据预处理阶段生成的词向量 <code>vec_tfidf</code> 文件 放置 <code>Sites/Model/all_raw</code> 目录下</li>
<li>将训练阶段生成的模型文件放置<code>Sites/Model/all_raw/model</code> 目录下</li>
<li>将 <code>Sites</code> 目录下文件放置 apache 相应网站目录下</li>
<li>访问 index.php</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;GitHub地址：&lt;a href=&quot;https://github.com/mJackie/SpamMessage&quot;&gt;https://github.com/mJackie/SpamMessage&lt;/a&gt;&lt;br&gt;实现一个垃圾短信识别系统，在给定的数据集上验证效果.&lt;br&gt;&lt;img src=&quot;/post_image/SpamMessage/index.jpeg&quot; alt=&quot;image&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Tech" scheme="http://mjackie.github.io/categories/Tech/"/>
    
    
      <category term="算法" scheme="http://mjackie.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="机器学习" scheme="http://mjackie.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>perl解析pcap文件</title>
    <link href="http://mjackie.github.io/Tech/cjera9vgf0026ehs6s042fj2a/"/>
    <id>http://mjackie.github.io/Tech/cjera9vgf0026ehs6s042fj2a/</id>
    <published>2017-11-25T10:24:00.000Z</published>
    <updated>2018-02-22T03:41:26.819Z</updated>
    
    <content type="html"><![CDATA[<p>关于<code>Pcap</code>文件解析的方法网上有很多相关文章，<code>Pcap</code>文件的格式以及使用<code>Wireshark</code>查看Pcap文件的方法也都有详细教程。然而利用<code>Perl</code>脚本语言对<code>Pcap</code>文件进行解析的相关代码和文章并没有。本文介绍了如何使用<code>Perl</code>脚本语言对<code>Pcap</code>文件进行解析。</p>
<h4 id="模块安装"><a href="#模块安装" class="headerlink" title="模块安装"></a>模块安装</h4><p> <code>Net::Pcap</code> 模块封装了用于解析Pcap文件的一些方法，首先介绍如何使用CPAN安装 <code>Net::Pcap</code>模块。</p>
<pre><code>//CPAN相关命令
//获得帮助　 
cpan&gt;h　 

//列出CPAN上所有模块的列表　 
cpan&gt;m　 

//安装模块　 
cpan&gt;install　Net::Pcap 

//退出　 
cpan&gt;q　 
</code></pre><p>　<br><a id="more"></a></p>
<h4 id="读取Pcap文件"><a href="#读取Pcap文件" class="headerlink" title="读取Pcap文件"></a>读取Pcap文件</h4><p><code>pcap_loop($pcap, $count, \&amp;callback, $user_data)</code><br>从pcap读取count个包,并且调用使用参数user_data调取callback函数。如果count为负，则循环读取直到错误发生。</p>
<pre><code>my $pcap = pcap_open_offline($fileDir, \$err) || die &quot;failed to open pcap file $pcap!&quot;;
while(1)
{
    $ret = pcap_loop($pcap, -1, \&amp;load_pcap, $this);
    if($ret == -1)
    {
        print &quot;error on processing packets in pcap file: $@!\n&quot;;
        die &quot;error on processing packets in pcap file: $@!\n&quot;;
        last;
    }
    elsif($ret == 0 || $ret == -2)
    {
        print &quot;end of pcap processing: $@!\n&quot;;
        last;
    }
}
</code></pre><h4 id="解析数据包"><a href="#解析数据包" class="headerlink" title="解析数据包"></a>解析数据包</h4><p>网络数据包格式如下图所示：<br><img src="/post_image/pcap.png" alt="image"></p>
<p><code>unpack (packformat, formatstr)</code> 函数将以机器格式存贮的值转化成Perl中值。packformat代表解析格式，formatstr为要解析的对象。</p>
<p>通过判断各个位置上的值从而确定包的类型。通过记录连接的状态，确定TCP三次握手的建立与解除。具体代码如下：</p>
<pre><code>foreach my $event (sort(keys(%{$packets})))
    {
        print &quot;testlog: a new packet begin----------------------- \n&quot;;

        my $packet = $packets-&gt;{$event}-&gt;{pkt};
        my $proto = unpack(&quot;H*&quot;, substr($packet, 12, 2));
        if($proto eq &quot;0800&quot;) #ipv4
        {
            $count ++;
            my $off = 14;
            my $iphl = (unpack(&quot;C&quot;, substr($packet, $off, 1)) &amp; 0x0f); # header length  , &lt;&lt;2 is the actual length
            my $ip_payload_len = unpack(&quot;n&quot;, substr($packet, $off + 2, 2)); #total length
            #print &quot;testlog: packet total length: &quot;. $ip_payload_len .&quot;\n&quot;;
            $proto = unpack(&quot;C&quot;, substr($packet, $off + 9, 1)); #net proto

            my $sip = inet_ntoa(substr($packet, $off + 12, 4)); #source ip addr
            my $dip = inet_ntoa(substr($packet, $off + 16, 4)); #dest ip addr

            # chop the padding bytes off
            $packet = substr($packet, 0, $off + $ip_payload_len); #a full packet

            if($iphl &gt; 5)
            {print &quot;Warning: ip packet with ip option\n&quot;;}

            my $ipPayloadLen = unpack(&quot;n&quot;, substr($packet, $off + 2, 2)) - ($iphl &lt;&lt; 2); #total length - header length 

            # skip ipv4 header
            $off += ($iphl &lt;&lt; 2);
            if($proto == 6)        # tcp session
            {
                my $tcp_hdrl = unpack(&quot;C&quot;, substr($packet, $off + 12, 1)) &gt;&gt; 2; # tcp header length , &lt;&lt;2 is the actual length
                my $tcp_flag = unpack(&quot;C&quot;, substr($packet, $off + 13, 1)); #tcp flag
                #print $tcp_flag . &quot;\n&quot;;
                my $sport = unpack(&quot;n&quot;, substr($packet, $off, 2));    #source port
                my $dport = unpack(&quot;n&quot;, substr($packet, $off + 2, 2));    #dest port

                if($ipPayloadLen - $tcp_hdrl &lt; 0) # eq 0
                {
                    print &quot;invalid tcp packet: $proto packet not supported!\n&quot;;    
                    last;
                }

                my $c = &quot;$sip:$sport&lt;-&gt;$dip:$dport&quot;;
                my $s = &quot;$dip:$dport&lt;-&gt;$sip:$sport&quot;;

                # recode session state
                if(!defined($session))
                {
                    print &quot;testlog: session will be defined! \n&quot;;
                    $session = {
                        id =&gt; $c,
                        cstate =&gt; &quot;closed&quot;,
                        sip =&gt; $sip,
                        dip =&gt; $dip,
                        sport =&gt; $sport,
                        dport =&gt; $dport
                    };
                }

                if($tcp_flag &amp; 0x04)
                {
                    print &quot;Warning: tcp session with RST, need mannual checking!Stop session analyzing: $frameID!\n&quot;;
                    $session-&gt;{cstate} = &quot;closed&quot;;
                }
                print &quot;testlog: session state: &quot;. $session-&gt;{cstate} .&quot;\n&quot;;
                if($session-&gt;{cstate} eq &quot;closed&quot;)    # open session
                {
                    if(($tcp_flag &amp; 0x02))        # syn open sesstion
                    {
                        $session-&gt;{cstate} = &quot;syn_sent&quot;;
                    }
                    else
                    {
                        if(length(substr($packet, $off + $tcp_hdrl)) &gt; 0)
                        {print &quot;Warning: tcp session disordered on closed, need mannual checking!Stop session analyzing: $sip : $sport &lt;-&gt; $dip : $dport \n&quot;;}
                    }

                }
                elsif($session-&gt;{cstate} eq &quot;syn_sent&quot;)
                {
                    #print ($tcp_flag);
                    #print &quot;\n&quot;;
                    if(($tcp_flag &amp; 0x12)==0x12){
                        print &quot;ok&quot;;
                    };
                    print &quot;\n&quot;;
                    if(($tcp_flag &amp; 0x02) &amp;&amp; ($sip eq $session-&gt;{sip}) &amp;&amp; ($sport eq $session-&gt;{sport})) # syn from client retransmission
                    {print &quot;tcp retransmission detected!\n&quot;;}
                    elsif(($tcp_flag &amp; 0x12) &amp;&amp; ($sip eq $session-&gt;{dip}) &amp;&amp; ($sport eq $session-&gt;{dport}))    # syn_ack from server
                    {$session-&gt;{cstate} = &quot;syn_rcvd&quot;;}
                    else
                    {
                        print &quot;Warning: tcp session disordered on syn_sent, need mannual checking!Stop session analyzing!\n&quot;;
                    }

                }
                elsif($session-&gt;{cstate} eq &quot;syn_rcvd&quot;)
                {
                    if(($tcp_flag &amp; 0x10) &amp;&amp; ($sip eq $session-&gt;{sip}) &amp;&amp; ($sport eq $session-&gt;{sport}))  # ack from client
                    {
                        $session-&gt;{cstate} = &quot;connected&quot;;         # won&apos;t check ack
                        print(FD &quot;CONNECT twoarm 1 0 tcp $dip $dport $sip $sport\n\n&quot;);
                    }
                    else
                    {print &quot;Warning: none ack packet on syn_rcvd!\n&quot;;}
                }
                elsif($session-&gt;{cstate} eq &quot;connected&quot;)
                {
                    #print &quot;testlog: $sip ---- $session-&gt;{sip} ----- $session-&gt;{dip}&quot;;
                    if($sip eq $session-&gt;{sip} &amp;&amp; ($sport eq $session-&gt;{sport}))        # from client
                    {
                        if($tcp_flag &amp; 0x01)
                        {
                            $session-&gt;{FIN} += 1;
                            $session-&gt;{FINFrom} = 1; # this is the second FIN, disconnect begin from server
                        }
                        else
                        {
                            if(length(substr($packet, $off + $tcp_hdrl)) &gt; 0) #TCP payload is not empty
                            {
                                $str_temp = unpack(&apos;H*&apos;,substr($packet, $off + $tcp_hdrl));
                                my @str_temp2 = split(//, $str_temp);
                                my $str_temp3;
                                for($i=0; $i&lt;@str_temp2; $i=$i+2){
                                    $str_temp3 = $str_temp3 . &quot;\\x&quot; . $str_temp2[$i] . $str_temp2[$i+1];
                                }
                                print &quot;$str_temp3 \n&quot;;
                                print(FD &quot;SEND 0 #\&quot;$str_temp3\&quot; NOW\n\n&quot;);
                            }
                        }
                    }
                    elsif($sip eq $session-&gt;{dip} &amp;&amp; ($sport eq $session-&gt;{dport}))
                    {
                        if($tcp_flag &amp; 0x01)
                        {
                            $session-&gt;{FIN} += 1;
                            $session-&gt;{FINFrom} = 0; # this is the second FIN, disconnect begin from client
                        }
                        else
                        {
                            if(length(substr($packet, $off + $tcp_hdrl)) &gt; 0)
                            {
                                $str_temp = unpack(&apos;H*&apos;,substr($packet, $off + $tcp_hdrl));
                                my @str_temp2 = split(//, $str_temp);
                                my $str_temp3;
                                for($i=0; $i&lt;@str_temp2; $i=$i+2){
                                    $str_temp3 = $str_temp3 . &quot;\\x&quot; . $str_temp2[$i] . $str_temp2[$i+1];
                                }
                                print &quot;$str_temp3 \n&quot;;
                                print(FD &quot;SEND 1 #\&quot;$str_temp3\&quot; NOW\n\n&quot;);
                            }
                        }
                    }
                    else
                    {
                        print &quot;invalid packet on connected tcp session\n&quot;;
                    }
                }
                if($session-&gt;{cstate} eq &quot;connected&quot; &amp;&amp; $session-&gt;{FIN} == 2)
                {
                    $FINFrom = $session-&gt;{FINFrom};
                    print(FD &quot;DISCONNECT $FINFrom\n&quot;);
                    $session-&gt;{cstate} = &quot;closed&quot;;
                    delete($session-&gt;{FIN});
                }
            }
        }
    }
</code></pre><h4 id="相关文章"><a href="#相关文章" class="headerlink" title="相关文章"></a>相关文章</h4><p><a href="https://metacpan.org/pod/Net::Pcap" target="_blank" rel="external">https://metacpan.org/pod/Net::Pcap</a><br><a href="http://blog.csdn.net/eroswang/arti" target="_blank" rel="external">http://blog.csdn.net/eroswang/arti</a><br><a href="http://blog.sina.com.cn/s/blog_4936c31d010115hj.htmlcle/details/2032564" target="_blank" rel="external">http://blog.sina.com.cn/s/blog_4936c31d010115hj.htmlcle/details/2032564</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;关于&lt;code&gt;Pcap&lt;/code&gt;文件解析的方法网上有很多相关文章，&lt;code&gt;Pcap&lt;/code&gt;文件的格式以及使用&lt;code&gt;Wireshark&lt;/code&gt;查看Pcap文件的方法也都有详细教程。然而利用&lt;code&gt;Perl&lt;/code&gt;脚本语言对&lt;code&gt;Pcap&lt;/code&gt;文件进行解析的相关代码和文章并没有。本文介绍了如何使用&lt;code&gt;Perl&lt;/code&gt;脚本语言对&lt;code&gt;Pcap&lt;/code&gt;文件进行解析。&lt;/p&gt;
&lt;h4 id=&quot;模块安装&quot;&gt;&lt;a href=&quot;#模块安装&quot; class=&quot;headerlink&quot; title=&quot;模块安装&quot;&gt;&lt;/a&gt;模块安装&lt;/h4&gt;&lt;p&gt; &lt;code&gt;Net::Pcap&lt;/code&gt; 模块封装了用于解析Pcap文件的一些方法，首先介绍如何使用CPAN安装 &lt;code&gt;Net::Pcap&lt;/code&gt;模块。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//CPAN相关命令
//获得帮助　 
cpan&amp;gt;h　 

//列出CPAN上所有模块的列表　 
cpan&amp;gt;m　 

//安装模块　 
cpan&amp;gt;install　Net::Pcap 

//退出　 
cpan&amp;gt;q　 
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;　&lt;br&gt;
    
    </summary>
    
      <category term="Tech" scheme="http://mjackie.github.io/categories/Tech/"/>
    
    
      <category term="perl" scheme="http://mjackie.github.io/tags/perl/"/>
    
      <category term="pcap" scheme="http://mjackie.github.io/tags/pcap/"/>
    
  </entry>
  
  <entry>
    <title>图像透视变换</title>
    <link href="http://mjackie.github.io/Tech/cjera9vgp002yehs6jarwtj13/"/>
    <id>http://mjackie.github.io/Tech/cjera9vgp002yehs6jarwtj13/</id>
    <published>2017-10-07T04:46:00.000Z</published>
    <updated>2017-10-16T15:58:17.000Z</updated>
    
    <content type="html"><![CDATA[<p>透视变换（Perspective Transformation)是指利用透视中心、像点、目标点三点共线的条件，按透视旋转定律使承影面（透视面）绕迹线（透视轴）旋转某一角度，破坏原有的投影光线束，仍能保持承影面上投影几何图形不变的变换。</p>
<p>记得本科时上的《计算机图形学》上学过图像的变换矩阵，当时还不知道有什么用，现在派上用场了。</p>
<p>透视变换的通用公式是：</p>
<p><img src="/post_image/toushibianhuan/1.png" alt="image"><br>其中，u，v是原始坐标点，写成增广向量形式，w=1。对应的变换后坐标为  <code>x=x&#39;/w&#39;,y=y&#39;/w&#39;</code> 。变换矩阵中， <code>a11,a12,a21,a22</code> 表示线性变换， <code>a31,a32</code> 表示平移， <code>a13,a23</code> 表示透视变换。<br><a id="more"></a><br>重写变换公式可得：<br><img src="/post_image/toushibianhuan/6.png" alt="image"></p>
<p>图像原始坐标点已知，如果我们能够指定原始图像中几个点对应变换后的坐标。则可通过上述公式计算得到变换矩阵中各分量的值。从而通过变换矩阵得到变换后的图像。</p>
<p>由于正方形的特殊性，选择正方形作为中间过度。通过将任意四边形先变换到正方形，再由正方形变换到四边形。通过这种方式便可将一个任意四边形变换到另一个任意四边形。<br><img src="/post_image/toushibianhuan/2.png" alt="image"></p>
<p>具体实现代码如下：</p>
<pre><code>private PerspectiveTransform(float a11, float a21, float a31, float a12, float a22, float a32,float a13, float a23, float a33) {
   this.a11 = a11;
   this.a12 = a12;
   this.a13 = a13;
   this.a21 = a21;
   this.a22 = a22;
   this.a23 = a23;
   this.a31 = a31;
   this.a32 = a32;
   this.a33 = a33;
 }

 public static PerspectiveTransform quadrilateralToQuadrilateral(float x0, float y0, float x1, float y1, float x2, float y2, float x3, float y3, float x0p, float y0p, float x1p, float y1p, float x2p, float y2p, float x3p, float y3p) {

   PerspectiveTransform qToS = quadrilateralToSquare(x0, y0, x1, y1, x2, y2, x3, y3);
   PerspectiveTransform sToQ = squareToQuadrilateral(x0p, y0p, x1p, y1p, x2p, y2p, x3p, y3p);
   return sToQ.times(qToS);
 }

 public void transformPoints(float[] points) {
   int max = points.length;
   float a11 = this.a11;
   float a12 = this.a12;
   float a13 = this.a13;
   float a21 = this.a21;
   float a22 = this.a22;
   float a23 = this.a23;
   float a31 = this.a31;
   float a32 = this.a32;
   float a33 = this.a33;
   for (int i = 0; i &lt; max; i += 2) {
     float x = points[i];
     float y = points[i + 1];
     float denominator = a13 * x + a23 * y + a33;
     points[i] = (a11 * x + a21 * y + a31) / denominator;
     points[i + 1] = (a12 * x + a22 * y + a32) / denominator;
   }
 }

 public void transformPoints(float[] xValues, float[] yValues) {
   int n = xValues.length;
   for (int i = 0; i &lt; n; i ++) {
     float x = xValues[i];
     float y = yValues[i];
     float denominator = a13 * x + a23 * y + a33;
     xValues[i] = (a11 * x + a21 * y + a31) / denominator;
     yValues[i] = (a12 * x + a22 * y + a32) / denominator;
   }
 }

 public static PerspectiveTransform squareToQuadrilateral(float x0, float y0,
                                                          float x1, float y1,
                                                          float x2, float y2,
                                                          float x3, float y3) {
   float dx3 = x0 - x1 + x2 - x3;
   float dy3 = y0 - y1 + y2 - y3;
   if (dx3 == 0.0f &amp;&amp; dy3 == 0.0f) {
     // Affine
     return new PerspectiveTransform(x1 - x0, x2 - x1, x0,
                                     y1 - y0, y2 - y1, y0,
                                     0.0f,    0.0f,    1.0f);
   } else {
     float dx1 = x1 - x2;
     float dx2 = x3 - x2;
     float dy1 = y1 - y2;
     float dy2 = y3 - y2;
     float denominator = dx1 * dy2 - dx2 * dy1;
     float a13 = (dx3 * dy2 - dx2 * dy3) / denominator;
     float a23 = (dx1 * dy3 - dx3 * dy1) / denominator;
     return new PerspectiveTransform(x1 - x0 + a13 * x1, x3 - x0 + a23 * x3, x0, y1 - y0 + a13 * y1, y3 - y0 + a23 * y3, y0, a13, a23, 1.0f);
   }
 }

 public static PerspectiveTransform quadrilateralToSquare(float x0, float y0, float x1, float y1, float x2, float y2, float x3, float y3) {
   // Here, the adjoint serves as the inverse:
   return squareToQuadrilateral(x0, y0, x1, y1, x2, y2, x3, y3).buildAdjoint();
 }

 PerspectiveTransform buildAdjoint() {
   // Adjoint is the transpose of the cofactor matrix:
   return new PerspectiveTransform(a22 * a33 - a23 * a32,
       a23 * a31 - a21 * a33,
       a21 * a32 - a22 * a31,
       a13 * a32 - a12 * a33,
       a11 * a33 - a13 * a31,
       a12 * a31 - a11 * a32,
       a12 * a23 - a13 * a22,
       a13 * a21 - a11 * a23,
       a11 * a22 - a12 * a21);
 }

 PerspectiveTransform times(PerspectiveTransform other) {
   return new PerspectiveTransform(a11 * other.a11 + a21 * other.a12 + a31 * other.a13,
       a11 * other.a21 + a21 * other.a22 + a31 * other.a23,
       a11 * other.a31 + a21 * other.a32 + a31 * other.a33,
       a12 * other.a11 + a22 * other.a12 + a32 * other.a13,
       a12 * other.a21 + a22 * other.a22 + a32 * other.a23,
       a12 * other.a31 + a22 * other.a32 + a32 * other.a33,
       a13 * other.a11 + a23 * other.a12 + a33 * other.a13,
       a13 * other.a21 + a23 * other.a22 + a33 * other.a23,
       a13 * other.a31 + a23 * other.a32 + a33 * other.a33);

 }
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;透视变换（Perspective Transformation)是指利用透视中心、像点、目标点三点共线的条件，按透视旋转定律使承影面（透视面）绕迹线（透视轴）旋转某一角度，破坏原有的投影光线束，仍能保持承影面上投影几何图形不变的变换。&lt;/p&gt;
&lt;p&gt;记得本科时上的《计算机图形学》上学过图像的变换矩阵，当时还不知道有什么用，现在派上用场了。&lt;/p&gt;
&lt;p&gt;透视变换的通用公式是：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/post_image/toushibianhuan/1.png&quot; alt=&quot;image&quot;&gt;&lt;br&gt;其中，u，v是原始坐标点，写成增广向量形式，w=1。对应的变换后坐标为  &lt;code&gt;x=x&amp;#39;/w&amp;#39;,y=y&amp;#39;/w&amp;#39;&lt;/code&gt; 。变换矩阵中， &lt;code&gt;a11,a12,a21,a22&lt;/code&gt; 表示线性变换， &lt;code&gt;a31,a32&lt;/code&gt; 表示平移， &lt;code&gt;a13,a23&lt;/code&gt; 表示透视变换。&lt;br&gt;
    
    </summary>
    
      <category term="Tech" scheme="http://mjackie.github.io/categories/Tech/"/>
    
    
      <category term="图像处理" scheme="http://mjackie.github.io/tags/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>好好学习，天天向上！</title>
    <link href="http://mjackie.github.io/Life/cjera9vgm002oehs6xlmn4t29/"/>
    <id>http://mjackie.github.io/Life/cjera9vgm002oehs6xlmn4t29/</id>
    <published>2017-09-11T03:21:00.000Z</published>
    <updated>2017-09-11T13:45:47.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天是17年9月11日，研究生正式上课的第一天。在这个时间节点上，总结过去半年的计算所实习经历，展望已经步入的研一校园生活。</p>
<p>半年的计算所实习生活收获良多，受益匪浅，是一段令人难忘的时光。总结起来可以概括为三点：</p>
<ul>
<li>科研工作的尝试</li>
</ul>
<p>从对科研工作的陌生与懵懂到了解与尝试，并试图提出自己的想法。在这个过程中，阅读文献的能力提高了，了解了期刊会议文章的组织结构。如何快速了解一篇文章的核心思想，找到自己的关注点。如何检索，下载自己所关注领域的文章。同时，自己的逻辑思维能力得到了锻炼，分析总结别人方法的优缺点，找到问题所在，并尝试提出自己的看法。这是一个不断尝试与修改的过程。每一个灵感的迸发与产生都是一次思维的升级。对科研工作也有了进一步的认识，科研所需的不仅仅是代码能力，学习能力的体现，而是一种综合能力的体现。写作能力，英语素质以及发现问题总结问题的能力都是科研中很重要的一部分。没有人会打开你的脑子看到你的想法，你要表达出来，写出来！</p>
<ul>
<li>工程项目的体会</li>
</ul>
<p>体会了一个实际项目从可行性分析到项目开发，性能优化，直到最后交付的过程。核心功能的开发时间反而比性能，可用性优化的时间要短。一个项目的完成，不仅仅是功能的实现，还要保证兼容性，性能，文档等多个方面的完成。在项目开发的过程中，自己读代码的能力也得到了明显的提升。阅读优秀的开源代码可以体会到别人的编程思想。读懂了别人的代码，才能在此基础上实现自己的需求。最后一点体会就是不要害怕困难，简单的问题，做着很开心，但收货往往很少。越是困难的问题，硬着头皮做下去，收获往往很大。</p>
<ul>
<li>小伙伴</li>
</ul>
<p>最大的收货莫过于朋友与友谊。还记得刚到所里的那几天，陌生的环境让我很不适应，大家仿佛都各行其是，似乎一下从学生阶段到了工作阶段，孤独感油然而生。渐渐的认识了许多同为大四提前入所的学生，和他们一起聚餐，一起出游，一起打游戏，让我渐渐找到了归属感。遇到他们，我真幸运！<br>特别要感谢我的导师张瀚文老师的关怀与指导，感谢课题组的每一位老师。</p>
<p>新学期，新气象。上周一连开了三个开学典礼，院里的，所里的和学校的，认识了许多新同学，熟悉了校园新环境。安逸的环境似乎让自己放松了警惕，也变得些许懒散。</p>
<p>时光易逝，要时刻督促自己不要浪费时光。希望在接下来的一年时间里能够</p>
<p>好好学习！</p>
<p>天天向上！</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天是17年9月11日，研究生正式上课的第一天。在这个时间节点上，总结过去半年的计算所实习经历，展望已经步入的研一校园生活。&lt;/p&gt;
&lt;p&gt;半年的计算所实习生活收获良多，受益匪浅，是一段令人难忘的时光。总结起来可以概括为三点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;科研工作的尝试&lt;/l
    
    </summary>
    
      <category term="Life" scheme="http://mjackie.github.io/categories/Life/"/>
    
    
  </entry>
  
  <entry>
    <title>利用Selenium爬取网络数据</title>
    <link href="http://mjackie.github.io/Tech/cjera9vgg0028ehs6vjr3mj7d/"/>
    <id>http://mjackie.github.io/Tech/cjera9vgg0028ehs6vjr3mj7d/</id>
    <published>2017-08-27T07:07:00.000Z</published>
    <updated>2017-08-31T09:03:31.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Selenium-简介"><a href="#Selenium-简介" class="headerlink" title="Selenium 简介"></a>Selenium 简介</h4><p>Selenium 是一个用于Web应用程序测试的工具。Selenium 测试直接运行在浏览器中，就像真正的用户在操作一样。框架底层使用 JavaScript 模拟真实用户对浏览器进行操作。测试脚本执行时，浏览器自动按照脚本代码做出点击，输入，打开，验证等操作，就像真实用户所做的一样，从终端用户的角度测试应用程序。</p>
<h4 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h4><pre><code>sudo apt-get install python默认2.7.12
sudo apt-get update        #更新下apt-get库否则下载pip会出错
sudo apt-get install python-pip        #默认是8.1.1
sudo pip install selenium    #安装selenium
sudo apt-get install firefox
sudo apt-get install xvfb
sudo pip install pyvirtualdisplay
下载 geckodriver        https://github.com/mozilla/geckodriver/releases
sudo chmod a+w geckodriver
</code></pre><a id="more"></a>
<h4 id="相关方法"><a href="#相关方法" class="headerlink" title="相关方法"></a>相关方法</h4><ul>
<li><p>定位页面中的元素</p>
<pre><code>find_element_by_id
find_element_by_name
find_element_by_xpath
find_element_by_link_text
find_element_by_partial_link_text
find_element_by_tag_name
find_element_by_class_name
find_element_by_css_selector
</code></pre></li>
<li><p>定位多个元素</p>
<pre><code>find_elements_by_name
find_elements_by_xpath
find_elements_by_link_text
find_elements_by_partial_link_text
find_elements_by_tag_name
find_elements_by_class_name
find_elements_by_css_selector
</code></pre></li>
<li><p>操作元素方法</p>
<pre><code>clear 清除元素的内容
send_keys 模拟按键输入
click 点击元素
submit 提交表单
</code></pre></li>
</ul>
<h4 id="延时等到"><a href="#延时等到" class="headerlink" title="延时等到"></a>延时等到</h4><p>利用Selenium爬取网络数据时，遇到的最多的问题就是页面或浏览器选项卡未加载出来时，对页面进行操作的问题。常见得报错包括IndexError: list index out of range等。</p>
<p>一种解决办法是，在一些操作后加 <code>time.sleep(3)</code> 来使进程等待一段固定时长，再进行后续操作。更好的办法应该是等到页面加载完成后，自动进行后续操作。</p>
<ul>
<li><p>等待元素出现后再执行后续操作</p>
<p>  wait模块的WebDriverWait类是显性等待类，先看下它有哪些参数与方法：</p>
<pre><code>def __init__(self, driver, timeout, poll_frequency=POLL_FREQUENCY, ignored_exceptions=None):
      &quot;&quot;&quot;Constructor, takes a WebDriver instance and timeout in seconds.

         :Args:
          - driver - Instance of WebDriver (Ie, Firefox, Chrome or Remote)
          - timeout - Number of seconds before timing out
          - poll_frequency - sleep interval between calls
            By default, it is 0.5 second.
          - ignored_exceptions - iterable structure of exception classes ignored during calls.
            By default, it contains NoSuchElementException only.

         Example:
          from selenium.webdriver.support.ui import WebDriverWait \n
          element = WebDriverWait(driver, 10).until(lambda x: x.find_element_by_id(&quot;someId&quot;)) \n
          is_disappeared = WebDriverWait(driver, 30, 1, (ElementNotVisibleException)).\ \n
                      until_not(lambda x: x.find_element_by_id(&quot;someId&quot;).is_displayed())
      &quot;&quot;&quot;
</code></pre><p>  调用方法如下：</p>
<pre><code>WebDriverWait(driver, 超时时长, 调用频率, 忽略异常).until(可执行方法, 超时时返回的信息)
</code></pre><p>  示例代码：</p>
<pre><code>WebDriverWait(driver, 600).until(lambda x: x.find_elements_by_xpath(&quot;//div[@class=\&quot;col-9 search-2017-2 pr10 pl0\&quot;]/div&quot;))
</code></pre></li>
<li><p>等待新的页面（选项卡）打开后执行后续操作</p>
<pre><code>while len(driver.window_handles)&lt;2:        #如果选项卡数量小于2
    first.click()
    time.sleep(1)
</code></pre></li>
</ul>
<h4 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h4><ul>
<li><a href="http://www.jb51.net/article/92672.htm" target="_blank" rel="external">http://www.jb51.net/article/92672.htm</a></li>
<li><a href="http://www.cnblogs.com/yoyoketang/p/6517477.html" target="_blank" rel="external">http://www.cnblogs.com/yoyoketang/p/6517477.html</a></li>
<li><a href="http://yueyue-test.iteye.com/blog/1864887" target="_blank" rel="external">http://yueyue-test.iteye.com/blog/1864887</a></li>
<li><a href="http://blog.csdn.net/eastmount/article/details/48108259" target="_blank" rel="external">http://blog.csdn.net/eastmount/article/details/48108259</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;Selenium-简介&quot;&gt;&lt;a href=&quot;#Selenium-简介&quot; class=&quot;headerlink&quot; title=&quot;Selenium 简介&quot;&gt;&lt;/a&gt;Selenium 简介&lt;/h4&gt;&lt;p&gt;Selenium 是一个用于Web应用程序测试的工具。Selenium 测试直接运行在浏览器中，就像真正的用户在操作一样。框架底层使用 JavaScript 模拟真实用户对浏览器进行操作。测试脚本执行时，浏览器自动按照脚本代码做出点击，输入，打开，验证等操作，就像真实用户所做的一样，从终端用户的角度测试应用程序。&lt;/p&gt;
&lt;h4 id=&quot;环境配置&quot;&gt;&lt;a href=&quot;#环境配置&quot; class=&quot;headerlink&quot; title=&quot;环境配置&quot;&gt;&lt;/a&gt;环境配置&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;sudo apt-get install python默认2.7.12
sudo apt-get update        #更新下apt-get库否则下载pip会出错
sudo apt-get install python-pip        #默认是8.1.1
sudo pip install selenium    #安装selenium
sudo apt-get install firefox
sudo apt-get install xvfb
sudo pip install pyvirtualdisplay
下载 geckodriver        https://github.com/mozilla/geckodriver/releases
sudo chmod a+w geckodriver
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="Tech" scheme="http://mjackie.github.io/categories/Tech/"/>
    
    
      <category term="Selenium" scheme="http://mjackie.github.io/tags/Selenium/"/>
    
      <category term="爬虫" scheme="http://mjackie.github.io/tags/%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title>利用 VBA 处理 Excel 数据</title>
    <link href="http://mjackie.github.io/Tech/cjera9vfz0016ehs6sndmpcs2/"/>
    <id>http://mjackie.github.io/Tech/cjera9vfz0016ehs6sndmpcs2/</id>
    <published>2017-08-19T07:32:00.000Z</published>
    <updated>2017-08-22T09:12:24.000Z</updated>
    
    <content type="html"><![CDATA[<p>Visual Basic for Applications（VBA）是Visual Basic的一种宏语言，是微软开发出来在其桌面应用程序中执行通用的自动化(OLE)任务的编程语言。主要能用来扩展Windows的应用程序功能，特别是Microsoft Office软件。</p>
<p>VBA 编写的宏命令可以取代手动对 Excel 的大量操作，也可以实现 Excel 未提供的函数。相比其他语言， VBA 天然的支持 Excel 大规模数据处理，对 Excel 格式数据处理更快，省去了格式字符匹配等问题。同时 VBA 可与 Excel 中自带的函数混合使用，提高了易用性。</p>
<a id="more"></a>
<h3 id="示例一：不同文件间拷贝数据"><a href="#示例一：不同文件间拷贝数据" class="headerlink" title="示例一：不同文件间拷贝数据"></a>示例一：不同文件间拷贝数据</h3><pre><code>Sub Electric()
    Dim target As Workbook
    Set target = Workbooks(&quot;a.xlsm&quot;)

    Dim source As Workbook
    Set source = Workbooks(&quot;b.xlsx&quot;)

    For i = 6 To target.Sheets(&quot;2014&quot;).Cells(Rows.Count, 1).End(xlUp).Row
        For j = 3 To target.Sheets(&quot;2014&quot;).Cells(Rows.Count, 1).End(xlUp).Row
            If target.Sheets(&quot;2014&quot;).Cells(i, 3) = source.Sheets(&quot;2014&quot;).Cells(j, 1) Then   &apos;如果单元格内容相同
                target.Sheets(&quot;2014&quot;).Cells(i, 24) = source.Sheets(&quot;2014&quot;).Cells(j, 2)
                Exit For
            End If
        Next
    Next
End Sub
</code></pre><h3 id="示例二：筛选出连续-5-行数据的项"><a href="#示例二：筛选出连续-5-行数据的项" class="headerlink" title="示例二：筛选出连续 5 行数据的项"></a>示例二：筛选出连续 5 行数据的项</h3><pre><code>Sub Statistic()

    Dim target As Workbook
    Set target = Workbooks(&quot;data.xlsm&quot;)

    &apos;使用“高级筛选”功能将不重复公司Id数据显示在sheet4中
    target.Sheets(&quot;sheet3&quot;).Columns(2).AdvancedFilter 2, , target.Sheets(&quot;sheet8&quot;).Cells(1, 1), 1
    s1 = target.Sheets(&quot;sheet8&quot;).Cells(Rows.Count, 1).End(xlUp).Row
    &apos;下面代码用COUNTIF函数统计重复次数
    For i = 1 To s1
        target.Sheets(&quot;sheet8&quot;).Cells(i, 2) = WorksheetFunction.CountIf(target.Sheets(&quot;sheet3&quot;).Columns(2), target.Sheets(&quot;sheet8&quot;).Cells(i, 1))
    Next


End Sub
Sub SelectByYear()

    Dim target As Workbook
    Set target = Workbooks(&quot;data.xlsm&quot;)
    m = 1

    For i = 2 To target.Sheets(&quot;sheet8&quot;).Cells(Rows.Count, 1).End(xlUp).Row
        If target.Sheets(&quot;sheet8&quot;).Cells(i, 2) &gt; 5 Then &apos;筛选5年以上的数据
            sstr = target.Sheets(&quot;sheet8&quot;).Cells(i, 1)

                With Worksheets(3).Range(&quot;b:b&quot;)
                    Set c = .Find(what:=sstr)
                    If Not c Is Nothing Then
                        firstAddress = c.Address
                        Do
                            r = c.Row
                            target.Sheets(&quot;sheet3&quot;).Rows(r).copy target.Sheets(&quot;sheet9&quot;).Cells(m, 1)
                            m = m + 1
                            Set c = .FindNext(c)
                        Loop While Not c Is Nothing And c.Address &lt;&gt; firstAddress
                    End If
                End With
        End If
    Next

End Sub
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Visual Basic for Applications（VBA）是Visual Basic的一种宏语言，是微软开发出来在其桌面应用程序中执行通用的自动化(OLE)任务的编程语言。主要能用来扩展Windows的应用程序功能，特别是Microsoft Office软件。&lt;/p&gt;
&lt;p&gt;VBA 编写的宏命令可以取代手动对 Excel 的大量操作，也可以实现 Excel 未提供的函数。相比其他语言， VBA 天然的支持 Excel 大规模数据处理，对 Excel 格式数据处理更快，省去了格式字符匹配等问题。同时 VBA 可与 Excel 中自带的函数混合使用，提高了易用性。&lt;/p&gt;
    
    </summary>
    
      <category term="Tech" scheme="http://mjackie.github.io/categories/Tech/"/>
    
    
      <category term="vba" scheme="http://mjackie.github.io/tags/vba/"/>
    
      <category term="数据处理" scheme="http://mjackie.github.io/tags/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>Zxing Camera 调用代码解析</title>
    <link href="http://mjackie.github.io/Tech/cjera9vg4001hehs6q53efr73/"/>
    <id>http://mjackie.github.io/Tech/cjera9vg4001hehs6q53efr73/</id>
    <published>2017-08-13T12:21:00.000Z</published>
    <updated>2017-08-15T13:19:40.000Z</updated>
    
    <content type="html"><![CDATA[<p>Zxing 是一个开源的，支持多种一维二维条码格式的图像处理类库，用 JAVA 实现，支持多种语言接口。同时提供了 android 摄像头调用相关类库，用于手持设备的扫码解码。</p>
<p>本文主要介绍了 Android 系统调用 Camera 实现扫码的过程解析。</p>
<h4 id="目录及相关类"><a href="#目录及相关类" class="headerlink" title="目录及相关类"></a>目录及相关类</h4><ul>
<li>activity: 扫码相关Activity<ul>
<li>CaptureActivity: 扫码主界面Activity</li>
<li>CaptureFragment: 承载预览界面SurfaceView 和取景框 ViewfinderView<a id="more"></a></li>
</ul>
</li>
<li>camera： 摄像头调用相关类<ul>
<li>AutoFocusCallback: 自动对焦后回调类</li>
<li>CameraConfigurationManager: Camera 配置管理与初始化</li>
<li>CameraManager: 封装了 Camera 操作相关方法，例如获取Camera图像，请求自动对焦等</li>
<li>PreviewCallback: 预览图像发生变化时的回调类</li>
</ul>
</li>
<li>decoding: 解码相关类<ul>
<li>CaptureActivityHandler: CaptureActivity 回调类，处理各种消息，例如：解码成功失败，对焦，请求预览图像等</li>
<li>DecodeHandler: 解码回调类，解码处理类，封装了调用 Zxing-core 的方法</li>
<li>DecodeThread: 解码线程，会根据解码类型调用 DecodeHandler</li>
</ul>
</li>
<li>view ： CaptureFragment中控件<ul>
<li>ViewfinderView: 取景框控件，绘制取景器，扫描线等</li>
</ul>
</li>
</ul>
<h4 id="扫码过程"><a href="#扫码过程" class="headerlink" title="扫码过程"></a>扫码过程</h4><ul>
<li>new CaptureActivity，初始化摄像头参数</li>
<li>new DecodeThread, 开始获取预览图像</li>
</ul>
<pre><code>decodeThread.start();
state = State.SUCCESS;
// Start ourselves capturing previews and decoding.
CameraManager.get().startPreview();
restartPreviewAndDecode();
</code></pre><ul>
<li>初始化PreviewCallback， 开始自动对焦， 绘制取景框</li>
</ul>
<pre><code>state = State.PREVIEW;      
CameraManager.get().requestPreviewFrame(decodeThread.getHandler(), R.id.decode);
CameraManager.get().requestAutoFocus(this, R.id.auto_focus);
fragment.drawViewfinder();
</code></pre><ul>
<li>循环执行自动对焦，获取预览图像到CaptureFragment</li>
<li>当预览图象发生变化时，会调用 PreviewCallback 中 onPreviewFrame() 方法, 获取图像 data 并发送 message 给DecodeHandler</li>
</ul>
<pre><code>Message message = previewHandler.obtainMessage(previewMessage, cameraResolution.x,cameraResolution.y, data);
message.sendToTarget();
</code></pre><ul>
<li>DecodeHandler 调用 decode 方法尝试解码，并发送解码结果message 给 CaptureActivityHandler。</li>
</ul>
<pre><code>if (rawResult != null) {
    long end = System.currentTimeMillis();
    Log.d(TAG, &quot;Found barcode (&quot; + (end - start) + &quot; ms):\n&quot; + rawResult.toString());
    Message message = Message.obtain(fragment.getHandler(), R.id.decode_succeeded, rawResult);
    Bundle bundle = new Bundle();
    bundle.putParcelable(DecodeThread.BARCODE_BITMAP, source.renderCroppedGreyscaleBitmap());
    message.setData(bundle);
    //Log.d(TAG, &quot;Sending decode succeeded message...&quot;);
    message.sendToTarget();
} else {
    Message message = Message.obtain(fragment.getHandler(), R.id.decode_failed);
    message.sendToTarget();
}
</code></pre><ul>
<li>CaptureActivityHandler 处理结果，解码失败继续尝试解码，解码成功返回结果进行跳转</li>
</ul>
<pre><code>if (message.what == R.id.decode_succeeded) {
        Log.d(TAG, &quot;Got decode succeeded message&quot;);
        state = State.SUCCESS;
        Bundle bundle = message.getData();
        Bitmap barcode = bundle == null ? null :
                (Bitmap) bundle.getParcelable(DecodeThread.BARCODE_BITMAP);

        fragment.handleDecode((Result) message.obj, barcode);

} else if (message.what == R.id.decode_failed) {

        state = State.PREVIEW;
        CameraManager.get().requestPreviewFrame(decodeThread.getHandler(), R.id.decode);
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Zxing 是一个开源的，支持多种一维二维条码格式的图像处理类库，用 JAVA 实现，支持多种语言接口。同时提供了 android 摄像头调用相关类库，用于手持设备的扫码解码。&lt;/p&gt;
&lt;p&gt;本文主要介绍了 Android 系统调用 Camera 实现扫码的过程解析。&lt;/p&gt;
&lt;h4 id=&quot;目录及相关类&quot;&gt;&lt;a href=&quot;#目录及相关类&quot; class=&quot;headerlink&quot; title=&quot;目录及相关类&quot;&gt;&lt;/a&gt;目录及相关类&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;activity: 扫码相关Activity&lt;ul&gt;
&lt;li&gt;CaptureActivity: 扫码主界面Activity&lt;/li&gt;
&lt;li&gt;CaptureFragment: 承载预览界面SurfaceView 和取景框 ViewfinderView
    
    </summary>
    
      <category term="Tech" scheme="http://mjackie.github.io/categories/Tech/"/>
    
    
      <category term="二维码" scheme="http://mjackie.github.io/tags/%E4%BA%8C%E7%BB%B4%E7%A0%81/"/>
    
      <category term="android" scheme="http://mjackie.github.io/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>LRU &amp; LFU 数据结构</title>
    <link href="http://mjackie.github.io/Tech/cjera9vg7001rehs6u0vy2fs0/"/>
    <id>http://mjackie.github.io/Tech/cjera9vg7001rehs6u0vy2fs0/</id>
    <published>2017-08-05T03:21:00.000Z</published>
    <updated>2017-08-11T09:22:13.000Z</updated>
    
    <content type="html"><![CDATA[<p>在内容替换算法中，LRU 与 LFU 是最为经典的两种置换算法。替换策略本身简单易懂，但在大规模内容处理时，设计高效的数据结构与插入查找方法使得时间复杂度较低并不简单。</p>
<h4 id="LRU"><a href="#LRU" class="headerlink" title="LRU"></a>LRU</h4><p>LRU 即 <code>Least Recently Used</code>,最近最少使用算法。当有新内容需要缓存时,LRU 算法使用新内容替换掉最久没有使用的内容。</p>
<p><img src="/post_image/lru&amp;lfu/lru.png" alt="image"><br><a id="more"></a></p>
<p>LRU 的数据结构包含两个部分,哈希表和双向循环链表。其中,哈希表用于实现缓存内容的快速查找;双向循环链表将缓存中的内容按照最后访问时间按顺时针方向由远至近组织在一起,头指针指向最后访问时间最久远的内容。当一个内容请求达到路由器缓存时,如果路由器缓存空间中已经缓存了该内容,则除直接向请求者返回内容外,还需要将该内容移动到双向循环链表头节点的左边;当一个新内容需要被缓存时,如果缓存空间满,则从双向链表头节点向右开始删除内容直到有足够空间存储新内容,然后将新内容附加到双向链表头节点左侧。LRU 数据结构的查找和更新时间复杂度为 O(1),空间复杂度为 O(N)。</p>
<h4 id="LFU"><a href="#LFU" class="headerlink" title="LFU"></a>LFU</h4><p>LFU 即 <code>Least Frequently Used</code>,最近最不频繁使用算法。由于 LFU 需要为每个内容维护一个状态,其实现相对于 LRU 来说要复杂的多。常见的 LFU 实现的查找和更新的复杂度都是 O(N),这对于大规模仿真实验来说是极其低效的。</p>
<p><img src="/post_image/lru&amp;lfu/lfu.png" alt="image"></p>
<p>LFU 的数据结构包含三个部分:一个双向链表、若干双向循环链表、一个哈希表。其中,哈希表的作用与 LRU 相同,用于内容的快速查找。双向链表是频数链表,即链表的每个节点是访问计数,每个频数节点包含一个指针指向一个双向循环链表,双向循环链表中存储着内容信息,即所有具有相同访问计数的内容都存储在一个对应的双向循环链表中。哈希表存储的即是内容名称到双向循环链表节点指针的映射关系。频数链表按照访问计数从小到大排列,当路由器因为存储新内容需要替换旧内容时,如果缓存空间不够,就从头节点 head 指向的频数节点指向的双向循环链表中删除内容节点以释放空间。如果第一个双向链表变为空,就将与之关联的频数节点从频数链表中删除。这样通过频数链表,所有内容就按照自己的访问计数有序的组织在一起。特别地,这里要求频数链表中每个节点指向的双向循环链表都不为空,如果为空就删除该频数节点,从而限制了频数链表的长度,保证时间复杂度和空间复杂度不会无限制增长。当缓存中的某个内容被访问时,需要对其访问计数加 1。此时,将其从原双向循环列表中删除,移动到对应访问计数的双向循环链表中,如果该频数节点不存在则创建一个新的频数节点和一个新的双向循环链表来存储该内容。经过这样复杂的维护,LFU 的查找和更新时间复杂度均为 O(1),空间复杂度为 O(N),为大规模实现仿真提供了良好的基础。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在内容替换算法中，LRU 与 LFU 是最为经典的两种置换算法。替换策略本身简单易懂，但在大规模内容处理时，设计高效的数据结构与插入查找方法使得时间复杂度较低并不简单。&lt;/p&gt;
&lt;h4 id=&quot;LRU&quot;&gt;&lt;a href=&quot;#LRU&quot; class=&quot;headerlink&quot; title=&quot;LRU&quot;&gt;&lt;/a&gt;LRU&lt;/h4&gt;&lt;p&gt;LRU 即 &lt;code&gt;Least Recently Used&lt;/code&gt;,最近最少使用算法。当有新内容需要缓存时,LRU 算法使用新内容替换掉最久没有使用的内容。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/post_image/lru&amp;amp;lfu/lru.png&quot; alt=&quot;image&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="Tech" scheme="http://mjackie.github.io/categories/Tech/"/>
    
    
      <category term="算法" scheme="http://mjackie.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="数据结构" scheme="http://mjackie.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://mjackie.github.io/Tech/cjera9vgk002iehs6lwkwdfmn/"/>
    <id>http://mjackie.github.io/Tech/cjera9vgk002iehs6lwkwdfmn/</id>
    <published>2017-07-31T11:29:29.000Z</published>
    <updated>2018-02-22T16:52:48.448Z</updated>
    
    <content type="html"><![CDATA[<h4 id="开启-关闭apache"><a href="#开启-关闭apache" class="headerlink" title="开启/关闭apache"></a>开启/关闭apache</h4><pre><code>sudo apachectl start
sudo apachectl stop
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;开启-关闭apache&quot;&gt;&lt;a href=&quot;#开启-关闭apache&quot; class=&quot;headerlink&quot; title=&quot;开启/关闭apache&quot;&gt;&lt;/a&gt;开启/关闭apache&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;sudo apachectl start
sudo 
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>QR 码解析算法</title>
    <link href="http://mjackie.github.io/Tech/cjera9vg9001uehs65ngphvci/"/>
    <id>http://mjackie.github.io/Tech/cjera9vg9001uehs65ngphvci/</id>
    <published>2017-07-26T16:00:00.000Z</published>
    <updated>2017-07-31T13:23:50.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="检测定位符流程"><a href="#检测定位符流程" class="headerlink" title="检测定位符流程"></a>检测定位符流程</h3><ul>
<li>横向扫描，检测 黑白黑白黑 的组合</li>
<li>默认隔<code>(3 * maxI) / (4 * MAX_MODULES)</code>行扫描一次，TRY_HARDER开启后逐行扫描</li>
<li>验证是否满足1:1:3:1:1的比例</li>
<li>检测纵向是否满足定位符特征</li>
<li>如果已经确定了两个定位符，则可跳过 <code>(Math.abs(firstConfirmedCenter.getX() - center.getX())-Math.abs(firstConfirmedCenter.getY() - center.getY())) / 2;</code> 行，继续扫描</li>
<li>如果提前确定3个定位符，且模块大小相近，则停止扫描 <code>haveMultiplyConfirmedCenters()</code></li>
<li>否则继续扫描图片</li>
<li>筛选掉和其他相差较大的定位符，选择匹配最好的3个定位符</li>
<li>确定三个定位符的中心坐标和各自位置 <code>orderBestPatterns()</code></li>
<li>返回检测到的三个定位符的结果</li>
</ul>
<a id="more"></a>
<h4 id="计算一个模块的大小"><a href="#计算一个模块的大小" class="headerlink" title="计算一个模块的大小"></a>计算一个模块的大小</h4><ul>
<li><code>calculateModuleSize()</code>按照x轴y轴分别计算，取平均值。</li>
<li>同时每次计算又分别调换参数计算两次，取平均值<code>calculateModuleSizeOneWay()</code></li>
<li>定位符的宽度/7，得到一个模块的像素数</li>
</ul>
<h4 id="计算维度，即一行有多少块"><a href="#计算维度，即一行有多少块" class="headerlink" title="计算维度，即一行有多少块"></a>计算维度，即一行有多少块</h4><pre><code>int tltrCentersDimension = MathUtils.round(ResultPoint.distance(topLeft, topRight) / moduleSize);
int tlblCentersDimension = MathUtils.round(ResultPoint.distance(topLeft, bottomLeft) / moduleSize);
int dimension = ((tltrCentersDimension + tlblCentersDimension) / 2) + 7;//因为坐标点是定位符中心点，所以要+7
</code></pre><h4 id="根据维度得到版本号"><a href="#根据维度得到版本号" class="headerlink" title="根据维度得到版本号"></a>根据维度得到版本号</h4><h4 id="计算alignment，预估右下角坐标"><a href="#计算alignment，预估右下角坐标" class="headerlink" title="计算alignment，预估右下角坐标"></a>计算alignment，预估右下角坐标</h4><h4 id="透视变换得到比特数组"><a href="#透视变换得到比特数组" class="headerlink" title="透视变换得到比特数组"></a>透视变换得到比特数组</h4>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;检测定位符流程&quot;&gt;&lt;a href=&quot;#检测定位符流程&quot; class=&quot;headerlink&quot; title=&quot;检测定位符流程&quot;&gt;&lt;/a&gt;检测定位符流程&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;横向扫描，检测 黑白黑白黑 的组合&lt;/li&gt;
&lt;li&gt;默认隔&lt;code&gt;(3 * maxI) / (4 * MAX_MODULES)&lt;/code&gt;行扫描一次，TRY_HARDER开启后逐行扫描&lt;/li&gt;
&lt;li&gt;验证是否满足1:1:3:1:1的比例&lt;/li&gt;
&lt;li&gt;检测纵向是否满足定位符特征&lt;/li&gt;
&lt;li&gt;如果已经确定了两个定位符，则可跳过 &lt;code&gt;(Math.abs(firstConfirmedCenter.getX() - center.getX())-Math.abs(firstConfirmedCenter.getY() - center.getY())) / 2;&lt;/code&gt; 行，继续扫描&lt;/li&gt;
&lt;li&gt;如果提前确定3个定位符，且模块大小相近，则停止扫描 &lt;code&gt;haveMultiplyConfirmedCenters()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;否则继续扫描图片&lt;/li&gt;
&lt;li&gt;筛选掉和其他相差较大的定位符，选择匹配最好的3个定位符&lt;/li&gt;
&lt;li&gt;确定三个定位符的中心坐标和各自位置 &lt;code&gt;orderBestPatterns()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;返回检测到的三个定位符的结果&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Tech" scheme="http://mjackie.github.io/categories/Tech/"/>
    
    
      <category term="算法" scheme="http://mjackie.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="二维码" scheme="http://mjackie.github.io/tags/%E4%BA%8C%E7%BB%B4%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>换电脑后如何恢复Hexo环境</title>
    <link href="http://mjackie.github.io/Tech/cjera9vgq0032ehs6770hp8wg/"/>
    <id>http://mjackie.github.io/Tech/cjera9vgq0032ehs6770hp8wg/</id>
    <published>2017-07-24T11:43:00.000Z</published>
    <updated>2018-02-03T11:14:44.410Z</updated>
    
    <content type="html"><![CDATA[<h3 id="首先本地安装-Git-和-Node-js"><a href="#首先本地安装-Git-和-Node-js" class="headerlink" title="首先本地安装 Git 和 Node.js"></a>首先本地安装 Git 和 Node.js</h3><pre><code>sudo apt-get install git-core    //安装 Git

curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.33.2/install.sh | bash        //安装 Node.js
nvm install stable
</code></pre><h3 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install -g hexo-cli</div></pre></td></tr></table></figure>
<h3 id="设置-Github-秘钥"><a href="#设置-Github-秘钥" class="headerlink" title="设置 Github 秘钥"></a>设置 Github 秘钥</h3><pre><code>ssh-keygen -t rsa -C &quot;youremail@example.com&quot; 
</code></pre><p>执行后会在用户主目录下生成.ssh目录，里面有id_rsa和id_rsa.pub两个文件，这两个就是SSH key密钥对，id_rsa是私钥，id_rsa.pub是公钥。</p>
<p>登陆GitHub，打开「Settings」-&gt;「SSH and GPG keys」，然后点击「new SSH key」，填上Title，在Key文本框里粘贴公钥id_rsa.pub文件的内容（千万不要粘贴成私钥了！），最后点击「Add SSH Key」。</p>
<a id="more"></a>
<h3 id="拷贝原文件"><a href="#拷贝原文件" class="headerlink" title="拷贝原文件"></a>拷贝原文件</h3><p>必须拷贝的文件：</p>
<ul>
<li><code>_config.yml</code> 站点配置文件</li>
<li><code>theme</code> 主题文件夹</li>
<li><code>source</code> 博文内容文件夹</li>
</ul>
<p>按需拷贝的文件：</p>
<ul>
<li><code>scaffolds</code> 文章模板文件夹</li>
<li><code>package.json</code> 使用哪些包</li>
<li><code>.gitignore</code> 指明部署时忽略的文件</li>
</ul>
<p>不必拷贝的文件：</p>
<ul>
<li><code>node_modules</code> npm install 会重新生成</li>
<li><code>public</code> hexo g 会重新生成</li>
<li><code>.deploy_git</code> hexo d 会重新生成</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;首先本地安装-Git-和-Node-js&quot;&gt;&lt;a href=&quot;#首先本地安装-Git-和-Node-js&quot; class=&quot;headerlink&quot; title=&quot;首先本地安装 Git 和 Node.js&quot;&gt;&lt;/a&gt;首先本地安装 Git 和 Node.js&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;sudo apt-get install git-core    //安装 Git

curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.33.2/install.sh | bash        //安装 Node.js
nvm install stable
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;安装Hexo&quot;&gt;&lt;a href=&quot;#安装Hexo&quot; class=&quot;headerlink&quot; title=&quot;安装Hexo&quot;&gt;&lt;/a&gt;安装Hexo&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;npm install -g hexo-cli&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;设置-Github-秘钥&quot;&gt;&lt;a href=&quot;#设置-Github-秘钥&quot; class=&quot;headerlink&quot; title=&quot;设置 Github 秘钥&quot;&gt;&lt;/a&gt;设置 Github 秘钥&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;ssh-keygen -t rsa -C &amp;quot;youremail@example.com&amp;quot; 
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;执行后会在用户主目录下生成.ssh目录，里面有id_rsa和id_rsa.pub两个文件，这两个就是SSH key密钥对，id_rsa是私钥，id_rsa.pub是公钥。&lt;/p&gt;
&lt;p&gt;登陆GitHub，打开「Settings」-&amp;gt;「SSH and GPG keys」，然后点击「new SSH key」，填上Title，在Key文本框里粘贴公钥id_rsa.pub文件的内容（千万不要粘贴成私钥了！），最后点击「Add SSH Key」。&lt;/p&gt;
    
    </summary>
    
      <category term="Tech" scheme="http://mjackie.github.io/categories/Tech/"/>
    
    
      <category term="blog" scheme="http://mjackie.github.io/tags/blog/"/>
    
      <category term="hexo" scheme="http://mjackie.github.io/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>机试题</title>
    <link href="http://mjackie.github.io/Tech/cjera9vgo002wehs6d0g6zmo8/"/>
    <id>http://mjackie.github.io/Tech/cjera9vgo002wehs6d0g6zmo8/</id>
    <published>2017-07-19T15:30:00.000Z</published>
    <updated>2017-07-31T11:49:05.000Z</updated>
    
    <content type="html"><![CDATA[<p>给夏令营学生出的机试题，虽然很简单，但要写出复杂度较低的方法并不容易。</p>
<h3 id="相对排名"><a href="#相对排名" class="headerlink" title="相对排名"></a>相对排名</h3><p>给定 N 个运动员的分数，计算他们的相对排名和得分最高的三个人，他们将分别获得奖项：”Gold Medal”, “Silver Medal” 和 “Bronze Medal”.</p>
<p><em>例子：</em></p>
<pre><code>Input: [5, 4, 3, 2, 1]
Output: [&quot;Gold Medal&quot;, &quot;Silver Medal&quot;, &quot;Bronze Medal&quot;, &quot;4&quot;, &quot;5&quot;]

Explanation: 
前三个是得分最高的三个人，他们分别获得&quot;Gold Medal&quot;, &quot;Silver Medal&quot; 和 &quot;Bronze Medal&quot;.
剩下的两名运动员，你只需根据他们的分数输出他们的相对排名.
</code></pre><a id="more"></a>
<p><em>注意：</em></p>
<ol>
<li>N 是不大于10000的正整数.</li>
<li>所有运动员的分数不会重复.</li>
</ol>
<h3 id="比特翻转"><a href="#比特翻转" class="headerlink" title="比特翻转"></a>比特翻转</h3><p>翻转给定的32位无符号整数。<br>例如，给定输入43261596（二进制为： <strong>00000010100101000001111010011100</strong>）,返回964176192（二进制为： <strong>00111001011110000010100101000000</strong>）</p>
<p><em>思考：</em>如果这个函数被多次调用，你会怎样最优化它?</p>
<h3 id="轮转有序数组中的最小值"><a href="#轮转有序数组中的最小值" class="headerlink" title="轮转有序数组中的最小值"></a>轮转有序数组中的最小值</h3><p>假设一个按升序排序的数组在预先未知的某个旋转轴上旋转,</p>
<p>(i.e., <code>0 1 2 4 5 6 7</code> 可能变为 <code>4 5 6 7 0 1 2</code>)</p>
<p>找出其中最小的元素.</p>
<p>你可以假设数组中没有重复值.</p>
<p><em>思考：</em>你写的算法时间，空间复杂度为多少？</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给夏令营学生出的机试题，虽然很简单，但要写出复杂度较低的方法并不容易。&lt;/p&gt;
&lt;h3 id=&quot;相对排名&quot;&gt;&lt;a href=&quot;#相对排名&quot; class=&quot;headerlink&quot; title=&quot;相对排名&quot;&gt;&lt;/a&gt;相对排名&lt;/h3&gt;&lt;p&gt;给定 N 个运动员的分数，计算他们的相对排名和得分最高的三个人，他们将分别获得奖项：”Gold Medal”, “Silver Medal” 和 “Bronze Medal”.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;例子：&lt;/em&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Input: [5, 4, 3, 2, 1]
Output: [&amp;quot;Gold Medal&amp;quot;, &amp;quot;Silver Medal&amp;quot;, &amp;quot;Bronze Medal&amp;quot;, &amp;quot;4&amp;quot;, &amp;quot;5&amp;quot;]

Explanation: 
前三个是得分最高的三个人，他们分别获得&amp;quot;Gold Medal&amp;quot;, &amp;quot;Silver Medal&amp;quot; 和 &amp;quot;Bronze Medal&amp;quot;.
剩下的两名运动员，你只需根据他们的分数输出他们的相对排名.
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="Tech" scheme="http://mjackie.github.io/categories/Tech/"/>
    
    
      <category term="算法" scheme="http://mjackie.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Java值传递与引用传递</title>
    <link href="http://mjackie.github.io/Tech/cjera9vg3001fehs6vbeaokzz/"/>
    <id>http://mjackie.github.io/Tech/cjera9vg3001fehs6vbeaokzz/</id>
    <published>2017-07-06T00:00:00.000Z</published>
    <updated>2017-07-31T11:28:51.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Java值传递"><a href="#Java值传递" class="headerlink" title="Java值传递"></a>Java值传递</h3><p>指的是在方法调用时，传递的参数是按值的拷贝传递。此时内存中存在<strong>两个</strong>相等的基本类型，即实际参数和形式参数，后面方法中的操作都是对形参这个值的修改，不影响实际参数的值.</p>
<pre><code>public class ParamTest {
    public static void main(String[] args) {
        int price = 5;
        doubleValue(price);
        System.out.print(price);    //【输出结果】: 5
    }

    public static void doubleValue(int x) {
        x = 2 * x;
    }
}
</code></pre><a id="more"></a>
<h4 id="过程解析"><a href="#过程解析" class="headerlink" title="过程解析"></a>过程解析</h4><ul>
<li>x被初始化为price值的一个拷贝，即5</li>
<li>x乘以2后等于10。但是price没有变化，依然是5</li>
<li>doubleValue执行完后，参数变量不再使用</li>
</ul>
<p><img src="/post_image/java-chuandi/zhichuandi.jpg" alt="zhichuandi"></p>
<h3 id="Java引用传递"><a href="#Java引用传递" class="headerlink" title="Java引用传递"></a>Java引用传递</h3><p>指的是在方法调用时，传递的参数是按引用进行传递，也就是变量所对应的内存空间的地址。在方法执行中，形参和实参内容相同，指向同一块内存地址，方法执行中对引用的操作将会影响到实际对象.</p>
<pre><code>class Student {
    private float score;
    public Student(float score) {
        this.score = score;
    }
    public void setScore(float score) {
        this.score = score;
    }
    public float getScore() {
        return score;
    }
}

public class ParamTest {
    public static void main(String[] args) {
        Student stu = new Student(80);
        raiseScore(stu);
        System.out.print(stu.getScore());    //【运行结果】：90
    }

    public static void raiseScore(Student s) {
        s.setScore(s.getScore() + 10);
    }
}
</code></pre><h4 id="过程解析-1"><a href="#过程解析-1" class="headerlink" title="过程解析"></a>过程解析</h4><ul>
<li>s被赋予stu值的拷贝，这里是一个对象的引用</li>
<li>raiseScore方法应用于这个应用。s和stu指向同一对象，该对象的分数增加了10</li>
<li>raiseScore方法结束后，s不再使用，stu指向的那个对象分数增加了10</li>
</ul>
<p><img src="/post_image/java-chuandi/yinyongchuandi.jpg" alt="yinyongchuandi"></p>
<h3 id="为什么说Java没有引用传递"><a href="#为什么说Java没有引用传递" class="headerlink" title="为什么说Java没有引用传递"></a>为什么说Java没有引用传递</h3><pre><code>class Student {

    private float score;

    public Student(float score) {
        this.score = score;
    }

    public void setScore(float score) {
        this.score = score;
    }

    public float getScore() {
        return score;
    }
}

public class ParamTest {
    public static void main(String[] args) {
        Student a = new Student(0);
        Student b = new Student(100);

        System.out.println(&quot;交换前：&quot;);        
        System.out.println(&quot;a的分数：&quot; + a.getScore() + &quot;--- b的分数：&quot; + b.getScore());        //【运行结果】：a的分数：0.0--- b的分数：100.0

        swap(a, b);

        System.out.println(&quot;交换后：&quot;);
        System.out.println(&quot;a的分数：&quot; + a.getScore() + &quot;--- b的分数：&quot; + b.getScore());        //【运行结果】：a的分数：0.0--- b的分数：100.0
    }

    public static void swap(Student x, Student y) {
        Student temp = x;
        x = y;
        y = temp;
    }
}
</code></pre><p>可以看出，上述代码运行后，a，b并没有实现交换。</p>
<h4 id="过程解析-2"><a href="#过程解析-2" class="headerlink" title="过程解析"></a>过程解析</h4><p><img src="/post_image/java-chuandi/swap1.jpg" alt="swap1"><br><img src="/post_image/java-chuandi/swap2.jpg" alt="swap2"><br><img src="/post_image/java-chuandi/swap3.jpg" alt="swap3"></p>
<p>从这个过程中可以看出，<strong>严格来讲，Java采用的不是引用调用</strong>。实际上，对象引用进行的是值传递，只不过是传递的对象的地址。</p>
<p><strong>Java中引用传递更类似 C++ 中指针作为参数</strong>. C++ 中指针是一个变量，只不过这个变量存储的是一个地址，指向内存的一个存储单元；而引用跟原来的变量实质上是同一个东西，只不过是原变量的一个别名而已.</p>
<p>总结一下java中方法参数的使用情况：</p>
<ul>
<li>一个方法不能修改一个基本数据类型的参数(即数值型和布尔型)</li>
<li>一个方法可以改变一个对象中变量的值</li>
<li>一个方法不能让对象参数引用一个新的对象</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Java值传递&quot;&gt;&lt;a href=&quot;#Java值传递&quot; class=&quot;headerlink&quot; title=&quot;Java值传递&quot;&gt;&lt;/a&gt;Java值传递&lt;/h3&gt;&lt;p&gt;指的是在方法调用时，传递的参数是按值的拷贝传递。此时内存中存在&lt;strong&gt;两个&lt;/strong&gt;相等的基本类型，即实际参数和形式参数，后面方法中的操作都是对形参这个值的修改，不影响实际参数的值.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class ParamTest {
    public static void main(String[] args) {
        int price = 5;
        doubleValue(price);
        System.out.print(price);    //【输出结果】: 5
    }

    public static void doubleValue(int x) {
        x = 2 * x;
    }
}
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="Tech" scheme="http://mjackie.github.io/categories/Tech/"/>
    
    
      <category term="java" scheme="http://mjackie.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Data Matrix 解析算法</title>
    <link href="http://mjackie.github.io/Tech/cjera9vg00019ehs6347ghh08/"/>
    <id>http://mjackie.github.io/Tech/cjera9vg00019ehs6347ghh08/</id>
    <published>2017-05-27T05:00:00.000Z</published>
    <updated>2017-07-31T11:28:12.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Data-Matrix"><a href="#Data-Matrix" class="headerlink" title="Data Matrix"></a>Data Matrix</h3><p>Data Matrix 是二维码的一种编码格式，原名Data code，由美国国际资料公司(International Data Matrix, 简称ID Matrix)于1989年发明。</p>
<p>Data Matrix二维条码的外观是一个由许多小方格所组成的正方形或长方形符号，以二位元码(Binary-code)方式来编码。深色代表“1”，浅色代表“0”。</p>
<p>定位图形是资料区域的一个周界，为一个模组宽度。其中两条邻边为暗实线，主要用于限定物理尺寸；定位和符号失真。另两条邻边由交替的深色和浅色模组组成，主要用于限定符号的单元结构，但也能帮助确定物理尺寸及失真。</p>
<p><img src="/post_image/datamatrix/datamatrix.png" alt="datamatrix"><br><a id="more"></a></p>
<h3 id="Data-Matrix-检测算法"><a href="#Data-Matrix-检测算法" class="headerlink" title="Data Matrix 检测算法"></a>Data Matrix 检测算法</h3><p>之前文章我们已经介绍过二维码的解码流程，本篇文章主要介绍Data Matrix Detect 算法，也就是如何从一幅图片中找出符号码的部分。</p>
<p>Data Matrix 不同于有显示定位符的二维码，例如 QR 码。所以定位符号图像的方式较为低效，即从图像中心向四周搜索，直到框住整个符号图像。这种检测方式也限定了图像中心区域必须为符号图像，否则则会检测失败。</p>
<p>检测步骤分为如下几步：</p>
<ol>
<li><p><strong>大致划出符号图像的位置。</strong>从图像中间画一个小矩形框，然后依次向四边推行，检测四边上是否有黑色的点，直到每一边都没有黑色的点为止。</p>
<p> 最终检测完四条边就会得到符号图像的大致位置。<br> <img src="/post_image/datamatrix/datamatrix2.jpg" alt="datamatrix2"></p>
</li>
<li><p><strong>找寻符号图像四个顶点。</strong>大致范围确定以后就需要确定符号图像四个角的顶点，有了四个角的顶点就可以进行透视变换，符号码图像也就能够取出。首先在大检测框的四个角用斜45度的直线去检测，如下图所示：</p>
<p> <img src="/post_image/datamatrix/datamatrix3.jpg" alt="datamatrix3"></p>
</li>
<li><p><strong>确定顶点方位和纬度。</strong><br>DataMatrix符号图像边缘的一圈成两个L形，一个L是实线，一个L是虚线。搜索的方法就是沿4条边的直线进行黑白变换次数的检测。黑白变换次数少的就是实线的边，多的就是虚线的边，再去找两个L形的交点，就确定了左下角和右上角这两点，然后再经过两点间距离的比较确定出四个顶点。</p>
<p> <img src="/post_image/datamatrix/datamatrix4.jpg" alt="datamatrix4"></p>
<p> 纬度就是符号的一边上有多少个模块，计算方法就是去找虚线定位符那一边有多少次黑白变换（DataMatrix的纬度都是偶数，所以要进行误差修正）。纬度计算出来了就可以知道每个模块的宽度，再由此就可以计算出四条边分别有多少个模块。这样就可以计算出符号的长宽比，就能够确定是长方形还是正方形。</p>
</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Data-Matrix&quot;&gt;&lt;a href=&quot;#Data-Matrix&quot; class=&quot;headerlink&quot; title=&quot;Data Matrix&quot;&gt;&lt;/a&gt;Data Matrix&lt;/h3&gt;&lt;p&gt;Data Matrix 是二维码的一种编码格式，原名Data code，由美国国际资料公司(International Data Matrix, 简称ID Matrix)于1989年发明。&lt;/p&gt;
&lt;p&gt;Data Matrix二维条码的外观是一个由许多小方格所组成的正方形或长方形符号，以二位元码(Binary-code)方式来编码。深色代表“1”，浅色代表“0”。&lt;/p&gt;
&lt;p&gt;定位图形是资料区域的一个周界，为一个模组宽度。其中两条邻边为暗实线，主要用于限定物理尺寸；定位和符号失真。另两条邻边由交替的深色和浅色模组组成，主要用于限定符号的单元结构，但也能帮助确定物理尺寸及失真。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/post_image/datamatrix/datamatrix.png&quot; alt=&quot;datamatrix&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="Tech" scheme="http://mjackie.github.io/categories/Tech/"/>
    
    
      <category term="算法" scheme="http://mjackie.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="二维码" scheme="http://mjackie.github.io/tags/%E4%BA%8C%E7%BB%B4%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>ccnSim 模拟器</title>
    <link href="http://mjackie.github.io/Tech/cjera9vg2001cehs6ib8amhgq/"/>
    <id>http://mjackie.github.io/Tech/cjera9vg2001cehs6ib8amhgq/</id>
    <published>2017-04-08T13:22:00.000Z</published>
    <updated>2017-08-15T13:16:05.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要解析 ccnSim 的架构及源码包各文件作用，关于 ccnSim 的各项配置参数，安装方法等 manual 文档中已介绍的内容本文不再介绍。</p>
<h2 id="什么是-ccnSim"><a href="#什么是-ccnSim" class="headerlink" title="什么是 ccnSim"></a>什么是 ccnSim</h2><p>ccnSim 是一个可扩展 chunk-level 的网络模拟器，基于OMNeT++框架，使用 C + + 编写，允许在大数量级的场景下模拟 CCN 网络。<br>ccnSim 模拟步骤以下三个阶段：</p>
<ul>
<li>编译 ccnSim 源文件， 链接 Omnet + + 框架</li>
<li>编写拓扑描述(通常用户只需要设置 CCN 节点之间的连接)</li>
<li>初始化每个模块的参数。这个可以直接读取 ned 文件或者 omnetpp.ini 初始化文件。</li>
<li>执行仿真</li>
</ul>
<a id="more"></a>
<h2 id="OMNeT-简介"><a href="#OMNeT-简介" class="headerlink" title="OMNeT ++ 简介"></a>OMNeT ++ 简介</h2><p>既然想要读懂 ccnSim 的代码，首先要对 Omnet++ 有所了解。OMNeT++是一个免费的、开源的多协议网络仿真软件，在网络仿真领域中占有十分重要的地位。</p>
<ul>
<li>OMNeT + + 是基于模块化的，最底层不可分割的模块是简单模块（ simple modules），简单模块可以组成复合模块（ compound modules）。</li>
<li>在 OMNeT + + 平台上，用户使用 NED 语言来定义组件的结构，一般一个组件（.h 和其对应的 .cc 文件）同时对应一个.net文件</li>
<li>组件之间通过 Message 进行交互，<code>handleMessage()</code> 方法用来处理消息</li>
</ul>
<p>不了解 Omnet++ 的可以先读一下软件的 Manual 文档和软件包中附带的 tictoc 示例代码</p>
<h2 id="ccnSim-架构"><a href="#ccnSim-架构" class="headerlink" title="ccnSim 架构"></a>ccnSim 架构</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>在了解相应代码之前，我们首先需要了解一下 ccnSim 作者在面向对象编程时的思路。</p>
<ul>
<li>网络由各个节点组成，每个节点都是一个 <code>core_layer</code> 对象，<code>core_layer</code> 又包含了 <code>base_cache</code> 和 <code>strategy_layer</code> 两个对象。</li>
<li>每个节点可以连接0个或1个 client ,client 代表一组用户，可以向网络发起内容请求。</li>
<li>用户可以在配置文件中设置相关的仿真参数，决定相应的缓存策略，路由策略<br><img src="/post_image/ccnSim.png" alt="ccnSim"></li>
</ul>
<h3 id="目录，核心文件介绍"><a href="#目录，核心文件介绍" class="headerlink" title="目录，核心文件介绍"></a>目录，核心文件介绍</h3><ul>
<li>include: 包含程序的头文件，多数.h文件对应 src 文件夹下的 .cc 文件<ul>
<li>ccnsim.h 是程序的入口文件，定义了一些全部变量，数据结构及相应的处理方法</li>
<li>需要注意的是<strong>缓存决策</strong>方法的源代码文件都在此目录下，直接在.h文件中定义了方法，没有与之对应的 src 文件。例如 ProbCache 算法对应 <code>prob_cache.h</code> 文件，LCD 算法对应 <code>lcd_policy.h</code> 文件</li>
</ul>
</li>
<li>modules： 模型文件（.ned）目录，所有的模型都由三个文件组成（<code>.ned</code>模型文件，<code>.h</code>声明文件，<code>.cc</code>源代码文件），目录结构与 src 一样，在 src 目录下统一介绍</li>
<li>networks：测试用的网络拓扑结构文件（<code>.ned</code>）目录</li>
<li>packets： 定义的交换信息格式文件存放的目录。定义时仅需定义 <code>.msg</code> 文件，对应的 <code>.cc</code> 和 <code>.h</code> 文件会在编译时自动产生</li>
<li>results 仿真实验结果数据存放目录</li>
<li>src 源代码目录<ul>
<li>clients <ul>
<li><code>client.cc</code> 定义 client 对象，client 会发起请求，处理返回的 data 数据，以及相应的数据统计</li>
</ul>
</li>
<li>content<ul>
<li><code>content_distribution.cc</code>  实现了内容初始化。初始化内容源仓库，内容分配等</li>
<li><code>zipf.cc</code> 实现内容 zipf 分布</li>
</ul>
</li>
<li>node<ul>
<li>cache ： 替换算法目录<ul>
<li><code>base_cache.cc</code>: base_cache 对象作为节点缓存空间的承载体，是<strong>其他缓存替换算法的父类</strong>。实现了缓存存取，查找的功能。</li>
<li><code>fifo_cache.cc</code>： 先进先出替换算法</li>
<li><code>lru_cache.cc</code>: 近期最少使用替换算法</li>
<li><code>random_cache.cc</code>: 随机替换算法</li>
</ul>
</li>
<li>strategy： 路由策略代码目录<ul>
<li><code>strategy_layer.cc</code>： 路由算法的父类，初始化FIB</li>
<li><code>MonopathStrategyLayer.cc</code>： 继承自<code>strategy_layer.cc</code> <strong>多数路由算法继承此类</strong>定义了路径选择方法等</li>
<li><code>spr.cc</code> ： 最近路由策略算法，将请求路由至最近的内容源仓库</li>
</ul>
</li>
<li><code>core_layer.cc</code>: <strong>节点的承载对象</strong>，处理请求（interest）与数据（data）</li>
</ul>
</li>
<li>statistics<ul>
<li><code>statistics.cc</code>: 统计代码，定义了统计规则，对仿真进行数据统计</li>
</ul>
</li>
</ul>
</li>
<li><code>omnetpp.ini</code>： 仿真配置文件，omnetpp 的配置文件语法规则</li>
</ul>
<h3 id="请求内容"><a href="#请求内容" class="headerlink" title="请求内容"></a>请求内容</h3><p>client 通过生成一个0到1的随机数，通过zipf函数，得到该分布概率下的最有一个内容。如果把内容按热度排序，那么从1到n的热度内容概率分布是这个随机数，n就是要发起请求的内容。<br>INTEREST 中的 chunk 由 id + number 组成，第一个 number 为0</p>
<h3 id="LRU-替换算法"><a href="#LRU-替换算法" class="headerlink" title="LRU 替换算法"></a>LRU 替换算法</h3><p>LRU 替换算法通过一个哈希表和一个双向链表实现。哈希表记录内容号，用于快速查找。双向链表通过两个指针分别记录刚被使用的和最久未被使用的。</p>
<pre><code>lru_pos* lru; //least recently used item
lru_pos* mru; //most recently used item
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要解析 ccnSim 的架构及源码包各文件作用，关于 ccnSim 的各项配置参数，安装方法等 manual 文档中已介绍的内容本文不再介绍。&lt;/p&gt;
&lt;h2 id=&quot;什么是-ccnSim&quot;&gt;&lt;a href=&quot;#什么是-ccnSim&quot; class=&quot;headerlink&quot; title=&quot;什么是 ccnSim&quot;&gt;&lt;/a&gt;什么是 ccnSim&lt;/h2&gt;&lt;p&gt;ccnSim 是一个可扩展 chunk-level 的网络模拟器，基于OMNeT++框架，使用 C + + 编写，允许在大数量级的场景下模拟 CCN 网络。&lt;br&gt;ccnSim 模拟步骤以下三个阶段：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;编译 ccnSim 源文件， 链接 Omnet + + 框架&lt;/li&gt;
&lt;li&gt;编写拓扑描述(通常用户只需要设置 CCN 节点之间的连接)&lt;/li&gt;
&lt;li&gt;初始化每个模块的参数。这个可以直接读取 ned 文件或者 omnetpp.ini 初始化文件。&lt;/li&gt;
&lt;li&gt;执行仿真&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Tech" scheme="http://mjackie.github.io/categories/Tech/"/>
    
    
      <category term="icn" scheme="http://mjackie.github.io/tags/icn/"/>
    
      <category term="c++" scheme="http://mjackie.github.io/tags/c/"/>
    
      <category term="c" scheme="http://mjackie.github.io/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>网站作品展示</title>
    <link href="http://mjackie.github.io/Tech/cjera9vgc0020ehs6655syl4o/"/>
    <id>http://mjackie.github.io/Tech/cjera9vgc0020ehs6655syl4o/</id>
    <published>2017-01-02T16:00:00.000Z</published>
    <updated>2017-07-31T13:21:59.000Z</updated>
    
    <content type="html"><![CDATA[<p>总结了一下大学做的一些网站工作。后台统一是学校的站群，所以工作主要集中在前端。民生学院作为河南大学的独立学院，宣传部的网站制作与维护工作都交给了我们实验室。统计了一下，自己独立完成的一共大概有十几个。虽然工作技术难度不大，不过在实践中还是学到了很多东西。</p>
<h5 id="民生学院财务部"><a href="#民生学院财务部" class="headerlink" title="民生学院财务部"></a>民生学院财务部</h5><p><img src="/post_image/web-zuopin/caiwubu.jpg" alt="image"><br><a id="more"></a></p>
<h5 id="支教邦"><a href="#支教邦" class="headerlink" title="支教邦"></a>支教邦</h5><p><img src="/post_image/web-zuopin/zhijiaobang.png" alt="image"><br><!--more--></p>
<h5 id="特种功能材料重点实验室"><a href="#特种功能材料重点实验室" class="headerlink" title="特种功能材料重点实验室"></a>特种功能材料重点实验室</h5><p><img src="/post_image/web-zuopin/cailiaolab.png" alt="image"></p>
<h5 id="民生学院人力资源部"><a href="#民生学院人力资源部" class="headerlink" title="民生学院人力资源部"></a>民生学院人力资源部</h5><p><img src="/post_image/web-zuopin/renliiziyuan.png" alt="image"></p>
<h5 id="民生学院纪检监察网"><a href="#民生学院纪检监察网" class="headerlink" title="民生学院纪检监察网"></a>民生学院纪检监察网</h5><p><img src="/post_image/web-zuopin/jijianjiancha.png" alt="image"></p>
<h5 id="艺术传媒学院"><a href="#艺术传媒学院" class="headerlink" title="艺术传媒学院"></a>艺术传媒学院</h5><p><img src="/post_image/web-zuopin/yishuchuanmei.png" alt="image"></p>
<h5 id="医学院"><a href="#医学院" class="headerlink" title="医学院"></a>医学院</h5><p><img src="/post_image/web-zuopin/yixueyuan.png" alt="image"></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;总结了一下大学做的一些网站工作。后台统一是学校的站群，所以工作主要集中在前端。民生学院作为河南大学的独立学院，宣传部的网站制作与维护工作都交给了我们实验室。统计了一下，自己独立完成的一共大概有十几个。虽然工作技术难度不大，不过在实践中还是学到了很多东西。&lt;/p&gt;
&lt;h5 id=&quot;民生学院财务部&quot;&gt;&lt;a href=&quot;#民生学院财务部&quot; class=&quot;headerlink&quot; title=&quot;民生学院财务部&quot;&gt;&lt;/a&gt;民生学院财务部&lt;/h5&gt;&lt;p&gt;&lt;img src=&quot;/post_image/web-zuopin/caiwubu.jpg&quot; alt=&quot;image&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="Tech" scheme="http://mjackie.github.io/categories/Tech/"/>
    
    
  </entry>
  
</feed>
