<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Jackie Liu&#39;s Blog</title>
  <subtitle>Just so so</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://mjackie.github.io/"/>
  <updated>2017-08-22T09:12:24.623Z</updated>
  <id>http://mjackie.github.io/</id>
  
  <author>
    <name>Jackie Liu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>利用 VBA 处理 Excel 数据</title>
    <link href="http://mjackie.github.io/Tech/cj6nko88n000w6l5k0zhmr9tg/"/>
    <id>http://mjackie.github.io/Tech/cj6nko88n000w6l5k0zhmr9tg/</id>
    <published>2017-08-19T07:32:00.000Z</published>
    <updated>2017-08-22T09:12:24.623Z</updated>
    
    <content type="html"><![CDATA[<p>Visual Basic for Applications（VBA）是Visual Basic的一种宏语言，是微软开发出来在其桌面应用程序中执行通用的自动化(OLE)任务的编程语言。主要能用来扩展Windows的应用程序功能，特别是Microsoft Office软件。</p>
<p>VBA 编写的宏命令可以取代手动对 Excel 的大量操作，也可以实现 Excel 未提供的函数。相比其他语言， VBA 天然的支持 Excel 大规模数据处理，对 Excel 格式数据处理更快，省去了格式字符匹配等问题。同时 VBA 可与 Excel 中自带的函数混合使用，提高了易用性。</p>
<a id="more"></a>
<h3 id="示例一：不同文件间拷贝数据"><a href="#示例一：不同文件间拷贝数据" class="headerlink" title="示例一：不同文件间拷贝数据"></a>示例一：不同文件间拷贝数据</h3><pre><code>Sub Electric()
    Dim target As Workbook
    Set target = Workbooks(&quot;a.xlsm&quot;)

    Dim source As Workbook
    Set source = Workbooks(&quot;b.xlsx&quot;)

    For i = 6 To target.Sheets(&quot;2014&quot;).Cells(Rows.Count, 1).End(xlUp).Row
        For j = 3 To target.Sheets(&quot;2014&quot;).Cells(Rows.Count, 1).End(xlUp).Row
            If target.Sheets(&quot;2014&quot;).Cells(i, 3) = source.Sheets(&quot;2014&quot;).Cells(j, 1) Then   &apos;如果单元格内容相同
                target.Sheets(&quot;2014&quot;).Cells(i, 24) = source.Sheets(&quot;2014&quot;).Cells(j, 2)
                Exit For
            End If
        Next
    Next
End Sub
</code></pre><h3 id="示例二：筛选出连续-5-行数据的项"><a href="#示例二：筛选出连续-5-行数据的项" class="headerlink" title="示例二：筛选出连续 5 行数据的项"></a>示例二：筛选出连续 5 行数据的项</h3><pre><code>Sub Statistic()

    Dim target As Workbook
    Set target = Workbooks(&quot;data.xlsm&quot;)

    &apos;使用“高级筛选”功能将不重复公司Id数据显示在sheet4中
    target.Sheets(&quot;sheet3&quot;).Columns(2).AdvancedFilter 2, , target.Sheets(&quot;sheet8&quot;).Cells(1, 1), 1
    s1 = target.Sheets(&quot;sheet8&quot;).Cells(Rows.Count, 1).End(xlUp).Row
    &apos;下面代码用COUNTIF函数统计重复次数
    For i = 1 To s1
        target.Sheets(&quot;sheet8&quot;).Cells(i, 2) = WorksheetFunction.CountIf(target.Sheets(&quot;sheet3&quot;).Columns(2), target.Sheets(&quot;sheet8&quot;).Cells(i, 1))
    Next


End Sub
Sub SelectByYear()

    Dim target As Workbook
    Set target = Workbooks(&quot;data.xlsm&quot;)
    m = 1

    For i = 2 To target.Sheets(&quot;sheet8&quot;).Cells(Rows.Count, 1).End(xlUp).Row
        If target.Sheets(&quot;sheet8&quot;).Cells(i, 2) &gt; 5 Then &apos;筛选5年以上的数据
            sstr = target.Sheets(&quot;sheet8&quot;).Cells(i, 1)

                With Worksheets(3).Range(&quot;b:b&quot;)
                    Set c = .Find(what:=sstr)
                    If Not c Is Nothing Then
                        firstAddress = c.Address
                        Do
                            r = c.Row
                            target.Sheets(&quot;sheet3&quot;).Rows(r).copy target.Sheets(&quot;sheet9&quot;).Cells(m, 1)
                            m = m + 1
                            Set c = .FindNext(c)
                        Loop While Not c Is Nothing And c.Address &lt;&gt; firstAddress
                    End If
                End With
        End If
    Next

End Sub
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Visual Basic for Applications（VBA）是Visual Basic的一种宏语言，是微软开发出来在其桌面应用程序中执行通用的自动化(OLE)任务的编程语言。主要能用来扩展Windows的应用程序功能，特别是Microsoft Office软件。&lt;/p&gt;
&lt;p&gt;VBA 编写的宏命令可以取代手动对 Excel 的大量操作，也可以实现 Excel 未提供的函数。相比其他语言， VBA 天然的支持 Excel 大规模数据处理，对 Excel 格式数据处理更快，省去了格式字符匹配等问题。同时 VBA 可与 Excel 中自带的函数混合使用，提高了易用性。&lt;/p&gt;
    
    </summary>
    
      <category term="Tech" scheme="http://mjackie.github.io/categories/Tech/"/>
    
    
      <category term="vba" scheme="http://mjackie.github.io/tags/vba/"/>
    
      <category term="数据处理" scheme="http://mjackie.github.io/tags/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>Zxing Camera 调用代码解析</title>
    <link href="http://mjackie.github.io/Tech/cj6nko88r000z6l5k49uvyrah/"/>
    <id>http://mjackie.github.io/Tech/cj6nko88r000z6l5k49uvyrah/</id>
    <published>2017-08-13T12:21:00.000Z</published>
    <updated>2017-08-15T13:19:40.080Z</updated>
    
    <content type="html"><![CDATA[<p>Zxing 是一个开源的，支持多种一维二维条码格式的图像处理类库，用 JAVA 实现，支持多种语言接口。同时提供了 android 摄像头调用相关类库，用于手持设备的扫码解码。</p>
<p>本文主要介绍了 Android 系统调用 Camera 实现扫码的过程解析。</p>
<h4 id="目录及相关类"><a href="#目录及相关类" class="headerlink" title="目录及相关类"></a>目录及相关类</h4><ul>
<li>activity: 扫码相关Activity<ul>
<li>CaptureActivity: 扫码主界面Activity</li>
<li>CaptureFragment: 承载预览界面SurfaceView 和取景框 ViewfinderView<a id="more"></a></li>
</ul>
</li>
<li>camera： 摄像头调用相关类<ul>
<li>AutoFocusCallback: 自动对焦后回调类</li>
<li>CameraConfigurationManager: Camera 配置管理与初始化</li>
<li>CameraManager: 封装了 Camera 操作相关方法，例如获取Camera图像，请求自动对焦等</li>
<li>PreviewCallback: 预览图像发生变化时的回调类</li>
</ul>
</li>
<li>decoding: 解码相关类<ul>
<li>CaptureActivityHandler: CaptureActivity 回调类，处理各种消息，例如：解码成功失败，对焦，请求预览图像等</li>
<li>DecodeHandler: 解码回调类，解码处理类，封装了调用 Zxing-core 的方法</li>
<li>DecodeThread: 解码线程，会根据解码类型调用 DecodeHandler</li>
</ul>
</li>
<li>view ： CaptureFragment中控件<ul>
<li>ViewfinderView: 取景框控件，绘制取景器，扫描线等</li>
</ul>
</li>
</ul>
<h4 id="扫码过程"><a href="#扫码过程" class="headerlink" title="扫码过程"></a>扫码过程</h4><ul>
<li>new CaptureActivity，初始化摄像头参数</li>
<li>new DecodeThread, 开始获取预览图像</li>
</ul>
<pre><code>decodeThread.start();
state = State.SUCCESS;
// Start ourselves capturing previews and decoding.
CameraManager.get().startPreview();
restartPreviewAndDecode();
</code></pre><ul>
<li>初始化PreviewCallback， 开始自动对焦， 绘制取景框</li>
</ul>
<pre><code>state = State.PREVIEW;      
CameraManager.get().requestPreviewFrame(decodeThread.getHandler(), R.id.decode);
CameraManager.get().requestAutoFocus(this, R.id.auto_focus);
fragment.drawViewfinder();
</code></pre><ul>
<li>循环执行自动对焦，获取预览图像到CaptureFragment</li>
<li>当预览图象发生变化时，会调用 PreviewCallback 中 onPreviewFrame() 方法, 获取图像 data 并发送 message 给DecodeHandler</li>
</ul>
<pre><code>Message message = previewHandler.obtainMessage(previewMessage, cameraResolution.x,cameraResolution.y, data);
message.sendToTarget();
</code></pre><ul>
<li>DecodeHandler 调用 decode 方法尝试解码，并发送解码结果message 给 CaptureActivityHandler。</li>
</ul>
<pre><code>if (rawResult != null) {
    long end = System.currentTimeMillis();
    Log.d(TAG, &quot;Found barcode (&quot; + (end - start) + &quot; ms):\n&quot; + rawResult.toString());
    Message message = Message.obtain(fragment.getHandler(), R.id.decode_succeeded, rawResult);
    Bundle bundle = new Bundle();
    bundle.putParcelable(DecodeThread.BARCODE_BITMAP, source.renderCroppedGreyscaleBitmap());
    message.setData(bundle);
    //Log.d(TAG, &quot;Sending decode succeeded message...&quot;);
    message.sendToTarget();
} else {
    Message message = Message.obtain(fragment.getHandler(), R.id.decode_failed);
    message.sendToTarget();
}
</code></pre><ul>
<li>CaptureActivityHandler 处理结果，解码失败继续尝试解码，解码成功返回结果进行跳转</li>
</ul>
<pre><code>if (message.what == R.id.decode_succeeded) {
        Log.d(TAG, &quot;Got decode succeeded message&quot;);
        state = State.SUCCESS;
        Bundle bundle = message.getData();
        Bitmap barcode = bundle == null ? null :
                (Bitmap) bundle.getParcelable(DecodeThread.BARCODE_BITMAP);

        fragment.handleDecode((Result) message.obj, barcode);

} else if (message.what == R.id.decode_failed) {

        state = State.PREVIEW;
        CameraManager.get().requestPreviewFrame(decodeThread.getHandler(), R.id.decode);
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Zxing 是一个开源的，支持多种一维二维条码格式的图像处理类库，用 JAVA 实现，支持多种语言接口。同时提供了 android 摄像头调用相关类库，用于手持设备的扫码解码。&lt;/p&gt;
&lt;p&gt;本文主要介绍了 Android 系统调用 Camera 实现扫码的过程解析。&lt;/p&gt;
&lt;h4 id=&quot;目录及相关类&quot;&gt;&lt;a href=&quot;#目录及相关类&quot; class=&quot;headerlink&quot; title=&quot;目录及相关类&quot;&gt;&lt;/a&gt;目录及相关类&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;activity: 扫码相关Activity&lt;ul&gt;
&lt;li&gt;CaptureActivity: 扫码主界面Activity&lt;/li&gt;
&lt;li&gt;CaptureFragment: 承载预览界面SurfaceView 和取景框 ViewfinderView
    
    </summary>
    
      <category term="Tech" scheme="http://mjackie.github.io/categories/Tech/"/>
    
    
      <category term="二维码" scheme="http://mjackie.github.io/tags/%E4%BA%8C%E7%BB%B4%E7%A0%81/"/>
    
      <category term="android" scheme="http://mjackie.github.io/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>LRU &amp; LFU 数据结构</title>
    <link href="http://mjackie.github.io/Tech/cj6nko8a6002c6l5k0wyqi5bz/"/>
    <id>http://mjackie.github.io/Tech/cj6nko8a6002c6l5k0wyqi5bz/</id>
    <published>2017-08-05T03:21:00.000Z</published>
    <updated>2017-08-11T09:22:13.890Z</updated>
    
    <content type="html"><![CDATA[<p>在内容替换算法中，LRU 与 LFU 是最为经典的两种置换算法。替换策略本身简单易懂，但在大规模内容处理时，设计高效的数据结构与插入查找方法使得时间复杂度较低并不简单。</p>
<h4 id="LRU"><a href="#LRU" class="headerlink" title="LRU"></a>LRU</h4><p>LRU 即 <code>Least Recently Used</code>,最近最少使用算法。当有新内容需要缓存时,LRU 算法使用新内容替换掉最久没有使用的内容。</p>
<p><img src="/post_image/lru&amp;lfu/lru.png" alt="image"><br><a id="more"></a></p>
<p>LRU 的数据结构包含两个部分,哈希表和双向循环链表。其中,哈希表用于实现缓存内容的快速查找;双向循环链表将缓存中的内容按照最后访问时间按顺时针方向由远至近组织在一起,头指针指向最后访问时间最久远的内容。当一个内容请求达到路由器缓存时,如果路由器缓存空间中已经缓存了该内容,则除直接向请求者返回内容外,还需要将该内容移动到双向循环链表头节点的左边;当一个新内容需要被缓存时,如果缓存空间满,则从双向链表头节点向右开始删除内容直到有足够空间存储新内容,然后将新内容附加到双向链表头节点左侧。LRU 数据结构的查找和更新时间复杂度为 O(1),空间复杂度为 O(N)。</p>
<h4 id="LFU"><a href="#LFU" class="headerlink" title="LFU"></a>LFU</h4><p>LFU 即 <code>Least Frequently Used</code>,最近最不频繁使用算法。由于 LFU 需要为每个内容维护一个状态,其实现相对于 LRU 来说要复杂的多。常见的 LFU 实现的查找和更新的复杂度都是 O(N),这对于大规模仿真实验来说是极其低效的。</p>
<p><img src="/post_image/lru&amp;lfu/lfu.png" alt="image"></p>
<p>LFU 的数据结构包含三个部分:一个双向链表、若干双向循环链表、一个哈希表。其中,哈希表的作用与 LRU 相同,用于内容的快速查找。双向链表是频数链表,即链表的每个节点是访问计数,每个频数节点包含一个指针指向一个双向循环链表,双向循环链表中存储着内容信息,即所有具有相同访问计数的内容都存储在一个对应的双向循环链表中。哈希表存储的即是内容名称到双向循环链表节点指针的映射关系。频数链表按照访问计数从小到大排列,当路由器因为存储新内容需要替换旧内容时,如果缓存空间不够,就从头节点 head 指向的频数节点指向的双向循环链表中删除内容节点以释放空间。如果第一个双向链表变为空,就将与之关联的频数节点从频数链表中删除。这样通过频数链表,所有内容就按照自己的访问计数有序的组织在一起。特别地,这里要求频数链表中每个节点指向的双向循环链表都不为空,如果为空就删除该频数节点,从而限制了频数链表的长度,保证时间复杂度和空间复杂度不会无限制增长。当缓存中的某个内容被访问时,需要对其访问计数加 1。此时,将其从原双向循环列表中删除,移动到对应访问计数的双向循环链表中,如果该频数节点不存在则创建一个新的频数节点和一个新的双向循环链表来存储该内容。经过这样复杂的维护,LFU 的查找和更新时间复杂度均为 O(1),空间复杂度为 O(N),为大规模实现仿真提供了良好的基础。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在内容替换算法中，LRU 与 LFU 是最为经典的两种置换算法。替换策略本身简单易懂，但在大规模内容处理时，设计高效的数据结构与插入查找方法使得时间复杂度较低并不简单。&lt;/p&gt;
&lt;h4 id=&quot;LRU&quot;&gt;&lt;a href=&quot;#LRU&quot; class=&quot;headerlink&quot; title=&quot;LRU&quot;&gt;&lt;/a&gt;LRU&lt;/h4&gt;&lt;p&gt;LRU 即 &lt;code&gt;Least Recently Used&lt;/code&gt;,最近最少使用算法。当有新内容需要缓存时,LRU 算法使用新内容替换掉最久没有使用的内容。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/post_image/lru&amp;amp;lfu/lru.png&quot; alt=&quot;image&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="Tech" scheme="http://mjackie.github.io/categories/Tech/"/>
    
    
      <category term="算法" scheme="http://mjackie.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="数据结构" scheme="http://mjackie.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>QR 码解析算法</title>
    <link href="http://mjackie.github.io/Tech/cj6nko89h001p6l5kzxfvi3xl/"/>
    <id>http://mjackie.github.io/Tech/cj6nko89h001p6l5kzxfvi3xl/</id>
    <published>2017-07-26T16:00:00.000Z</published>
    <updated>2017-07-31T13:23:50.099Z</updated>
    
    <content type="html"><![CDATA[<h3 id="检测定位符流程"><a href="#检测定位符流程" class="headerlink" title="检测定位符流程"></a>检测定位符流程</h3><ul>
<li>横向扫描，检测 黑白黑白黑 的组合</li>
<li>默认隔<code>(3 * maxI) / (4 * MAX_MODULES)</code>行扫描一次，TRY_HARDER开启后逐行扫描</li>
<li>验证是否满足1:1:3:1:1的比例</li>
<li>检测纵向是否满足定位符特征</li>
<li>如果已经确定了两个定位符，则可跳过 <code>(Math.abs(firstConfirmedCenter.getX() - center.getX())-Math.abs(firstConfirmedCenter.getY() - center.getY())) / 2;</code> 行，继续扫描</li>
<li>如果提前确定3个定位符，且模块大小相近，则停止扫描 <code>haveMultiplyConfirmedCenters()</code></li>
<li>否则继续扫描图片</li>
<li>筛选掉和其他相差较大的定位符，选择匹配最好的3个定位符</li>
<li>确定三个定位符的中心坐标和各自位置 <code>orderBestPatterns()</code></li>
<li>返回检测到的三个定位符的结果</li>
</ul>
<a id="more"></a>
<h4 id="计算一个模块的大小"><a href="#计算一个模块的大小" class="headerlink" title="计算一个模块的大小"></a>计算一个模块的大小</h4><ul>
<li><code>calculateModuleSize()</code>按照x轴y轴分别计算，取平均值。</li>
<li>同时每次计算又分别调换参数计算两次，取平均值<code>calculateModuleSizeOneWay()</code></li>
<li>定位符的宽度/7，得到一个模块的像素数</li>
</ul>
<h4 id="计算维度，即一行有多少块"><a href="#计算维度，即一行有多少块" class="headerlink" title="计算维度，即一行有多少块"></a>计算维度，即一行有多少块</h4><pre><code>int tltrCentersDimension = MathUtils.round(ResultPoint.distance(topLeft, topRight) / moduleSize);
int tlblCentersDimension = MathUtils.round(ResultPoint.distance(topLeft, bottomLeft) / moduleSize);
int dimension = ((tltrCentersDimension + tlblCentersDimension) / 2) + 7;//因为坐标点是定位符中心点，所以要+7
</code></pre><h4 id="根据维度得到版本号"><a href="#根据维度得到版本号" class="headerlink" title="根据维度得到版本号"></a>根据维度得到版本号</h4><h4 id="计算alignment，预估右下角坐标"><a href="#计算alignment，预估右下角坐标" class="headerlink" title="计算alignment，预估右下角坐标"></a>计算alignment，预估右下角坐标</h4><h4 id="透视变换得到比特数组"><a href="#透视变换得到比特数组" class="headerlink" title="透视变换得到比特数组"></a>透视变换得到比特数组</h4>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;检测定位符流程&quot;&gt;&lt;a href=&quot;#检测定位符流程&quot; class=&quot;headerlink&quot; title=&quot;检测定位符流程&quot;&gt;&lt;/a&gt;检测定位符流程&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;横向扫描，检测 黑白黑白黑 的组合&lt;/li&gt;
&lt;li&gt;默认隔&lt;code&gt;(3 * maxI) / (4 * MAX_MODULES)&lt;/code&gt;行扫描一次，TRY_HARDER开启后逐行扫描&lt;/li&gt;
&lt;li&gt;验证是否满足1:1:3:1:1的比例&lt;/li&gt;
&lt;li&gt;检测纵向是否满足定位符特征&lt;/li&gt;
&lt;li&gt;如果已经确定了两个定位符，则可跳过 &lt;code&gt;(Math.abs(firstConfirmedCenter.getX() - center.getX())-Math.abs(firstConfirmedCenter.getY() - center.getY())) / 2;&lt;/code&gt; 行，继续扫描&lt;/li&gt;
&lt;li&gt;如果提前确定3个定位符，且模块大小相近，则停止扫描 &lt;code&gt;haveMultiplyConfirmedCenters()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;否则继续扫描图片&lt;/li&gt;
&lt;li&gt;筛选掉和其他相差较大的定位符，选择匹配最好的3个定位符&lt;/li&gt;
&lt;li&gt;确定三个定位符的中心坐标和各自位置 &lt;code&gt;orderBestPatterns()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;返回检测到的三个定位符的结果&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Tech" scheme="http://mjackie.github.io/categories/Tech/"/>
    
    
      <category term="二维码" scheme="http://mjackie.github.io/tags/%E4%BA%8C%E7%BB%B4%E7%A0%81/"/>
    
      <category term="算法" scheme="http://mjackie.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>换电脑后如何恢复Hexo环境</title>
    <link href="http://mjackie.github.io/Tech/cj6nko8a1002a6l5k1unhbp0e/"/>
    <id>http://mjackie.github.io/Tech/cj6nko8a1002a6l5k1unhbp0e/</id>
    <published>2017-07-24T11:43:00.000Z</published>
    <updated>2017-07-31T11:27:27.823Z</updated>
    
    <content type="html"><![CDATA[<h3 id="首先本地安装-Git-和-Node-js"><a href="#首先本地安装-Git-和-Node-js" class="headerlink" title="首先本地安装 Git 和 Node.js"></a>首先本地安装 Git 和 Node.js</h3><pre><code>sudo apt-get install git-core    //安装 Git

curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.33.2/install.sh | bash        //安装 Node.js
nvm install stable
</code></pre><h3 id="设置-Github-秘钥"><a href="#设置-Github-秘钥" class="headerlink" title="设置 Github 秘钥"></a>设置 Github 秘钥</h3><pre><code>ssh-keygen -t rsa -C &quot;youremail@example.com&quot; 
</code></pre><p>执行后会在用户主目录下生成.ssh目录，里面有id_rsa和id_rsa.pub两个文件，这两个就是SSH key密钥对，id_rsa是私钥，id_rsa.pub是公钥。</p>
<p>登陆GitHub，打开「Settings」-&gt;「SSH and GPG keys」，然后点击「new SSH key」，填上Title，在Key文本框里粘贴公钥id_rsa.pub文件的内容（千万不要粘贴成私钥了！），最后点击「Add SSH Key」。</p>
<a id="more"></a>
<h3 id="拷贝原文件"><a href="#拷贝原文件" class="headerlink" title="拷贝原文件"></a>拷贝原文件</h3><p>必须拷贝的文件：</p>
<ul>
<li><code>_config.yml</code> 站点配置文件</li>
<li><code>theme</code> 主题文件夹</li>
<li><code>source</code> 博文内容文件夹</li>
</ul>
<p>按需拷贝的文件：</p>
<ul>
<li><code>scaffolds</code> 文章模板文件夹</li>
<li><code>package.json</code> 使用哪些包</li>
<li><code>.gitignore</code> 指明部署时忽略的文件</li>
</ul>
<p>不必拷贝的文件：</p>
<ul>
<li><code>node_modules</code> npm install 会重新生成</li>
<li><code>public</code> hexo g 会重新生成</li>
<li><code>.deploy_git</code> hexo d 会重新生成</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;首先本地安装-Git-和-Node-js&quot;&gt;&lt;a href=&quot;#首先本地安装-Git-和-Node-js&quot; class=&quot;headerlink&quot; title=&quot;首先本地安装 Git 和 Node.js&quot;&gt;&lt;/a&gt;首先本地安装 Git 和 Node.js&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;sudo apt-get install git-core    //安装 Git

curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.33.2/install.sh | bash        //安装 Node.js
nvm install stable
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;设置-Github-秘钥&quot;&gt;&lt;a href=&quot;#设置-Github-秘钥&quot; class=&quot;headerlink&quot; title=&quot;设置 Github 秘钥&quot;&gt;&lt;/a&gt;设置 Github 秘钥&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;ssh-keygen -t rsa -C &amp;quot;youremail@example.com&amp;quot; 
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;执行后会在用户主目录下生成.ssh目录，里面有id_rsa和id_rsa.pub两个文件，这两个就是SSH key密钥对，id_rsa是私钥，id_rsa.pub是公钥。&lt;/p&gt;
&lt;p&gt;登陆GitHub，打开「Settings」-&amp;gt;「SSH and GPG keys」，然后点击「new SSH key」，填上Title，在Key文本框里粘贴公钥id_rsa.pub文件的内容（千万不要粘贴成私钥了！），最后点击「Add SSH Key」。&lt;/p&gt;
    
    </summary>
    
      <category term="Tech" scheme="http://mjackie.github.io/categories/Tech/"/>
    
    
      <category term="blog" scheme="http://mjackie.github.io/tags/blog/"/>
    
      <category term="hexo" scheme="http://mjackie.github.io/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>机试题</title>
    <link href="http://mjackie.github.io/Tech/cj6nko8ab002j6l5krl1r4441/"/>
    <id>http://mjackie.github.io/Tech/cj6nko8ab002j6l5krl1r4441/</id>
    <published>2017-07-19T15:30:00.000Z</published>
    <updated>2017-07-31T11:49:05.687Z</updated>
    
    <content type="html"><![CDATA[<p>给夏令营学生出的机试题，虽然很简单，但要写出复杂度较低的方法并不容易。</p>
<h3 id="相对排名"><a href="#相对排名" class="headerlink" title="相对排名"></a>相对排名</h3><p>给定 N 个运动员的分数，计算他们的相对排名和得分最高的三个人，他们将分别获得奖项：”Gold Medal”, “Silver Medal” 和 “Bronze Medal”.</p>
<p><em>例子：</em></p>
<pre><code>Input: [5, 4, 3, 2, 1]
Output: [&quot;Gold Medal&quot;, &quot;Silver Medal&quot;, &quot;Bronze Medal&quot;, &quot;4&quot;, &quot;5&quot;]

Explanation: 
前三个是得分最高的三个人，他们分别获得&quot;Gold Medal&quot;, &quot;Silver Medal&quot; 和 &quot;Bronze Medal&quot;.
剩下的两名运动员，你只需根据他们的分数输出他们的相对排名.
</code></pre><a id="more"></a>
<p><em>注意：</em></p>
<ol>
<li>N 是不大于10000的正整数.</li>
<li>所有运动员的分数不会重复.</li>
</ol>
<h3 id="比特翻转"><a href="#比特翻转" class="headerlink" title="比特翻转"></a>比特翻转</h3><p>翻转给定的32位无符号整数。<br>例如，给定输入43261596（二进制为： <strong>00000010100101000001111010011100</strong>）,返回964176192（二进制为： <strong>00111001011110000010100101000000</strong>）</p>
<p><em>思考：</em>如果这个函数被多次调用，你会怎样最优化它?</p>
<h3 id="轮转有序数组中的最小值"><a href="#轮转有序数组中的最小值" class="headerlink" title="轮转有序数组中的最小值"></a>轮转有序数组中的最小值</h3><p>假设一个按升序排序的数组在预先未知的某个旋转轴上旋转,</p>
<p>(i.e., <code>0 1 2 4 5 6 7</code> 可能变为 <code>4 5 6 7 0 1 2</code>)</p>
<p>找出其中最小的元素.</p>
<p>你可以假设数组中没有重复值.</p>
<p><em>思考：</em>你写的算法时间，空间复杂度为多少？</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给夏令营学生出的机试题，虽然很简单，但要写出复杂度较低的方法并不容易。&lt;/p&gt;
&lt;h3 id=&quot;相对排名&quot;&gt;&lt;a href=&quot;#相对排名&quot; class=&quot;headerlink&quot; title=&quot;相对排名&quot;&gt;&lt;/a&gt;相对排名&lt;/h3&gt;&lt;p&gt;给定 N 个运动员的分数，计算他们的相对排名和得分最高的三个人，他们将分别获得奖项：”Gold Medal”, “Silver Medal” 和 “Bronze Medal”.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;例子：&lt;/em&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Input: [5, 4, 3, 2, 1]
Output: [&amp;quot;Gold Medal&amp;quot;, &amp;quot;Silver Medal&amp;quot;, &amp;quot;Bronze Medal&amp;quot;, &amp;quot;4&amp;quot;, &amp;quot;5&amp;quot;]

Explanation: 
前三个是得分最高的三个人，他们分别获得&amp;quot;Gold Medal&amp;quot;, &amp;quot;Silver Medal&amp;quot; 和 &amp;quot;Bronze Medal&amp;quot;.
剩下的两名运动员，你只需根据他们的分数输出他们的相对排名.
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="Tech" scheme="http://mjackie.github.io/categories/Tech/"/>
    
    
      <category term="算法" scheme="http://mjackie.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Java值传递与引用传递</title>
    <link href="http://mjackie.github.io/Tech/cj6nko89e001j6l5k6qqvvurs/"/>
    <id>http://mjackie.github.io/Tech/cj6nko89e001j6l5k6qqvvurs/</id>
    <published>2017-07-06T00:00:00.000Z</published>
    <updated>2017-07-31T11:28:51.015Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Java值传递"><a href="#Java值传递" class="headerlink" title="Java值传递"></a>Java值传递</h3><p>指的是在方法调用时，传递的参数是按值的拷贝传递。此时内存中存在<strong>两个</strong>相等的基本类型，即实际参数和形式参数，后面方法中的操作都是对形参这个值的修改，不影响实际参数的值.</p>
<pre><code>public class ParamTest {
    public static void main(String[] args) {
        int price = 5;
        doubleValue(price);
        System.out.print(price);    //【输出结果】: 5
    }

    public static void doubleValue(int x) {
        x = 2 * x;
    }
}
</code></pre><a id="more"></a>
<h4 id="过程解析"><a href="#过程解析" class="headerlink" title="过程解析"></a>过程解析</h4><ul>
<li>x被初始化为price值的一个拷贝，即5</li>
<li>x乘以2后等于10。但是price没有变化，依然是5</li>
<li>doubleValue执行完后，参数变量不再使用</li>
</ul>
<p><img src="/post_image/java-chuandi/zhichuandi.jpg" alt="zhichuandi"></p>
<h3 id="Java引用传递"><a href="#Java引用传递" class="headerlink" title="Java引用传递"></a>Java引用传递</h3><p>指的是在方法调用时，传递的参数是按引用进行传递，也就是变量所对应的内存空间的地址。在方法执行中，形参和实参内容相同，指向同一块内存地址，方法执行中对引用的操作将会影响到实际对象.</p>
<pre><code>class Student {
    private float score;
    public Student(float score) {
        this.score = score;
    }
    public void setScore(float score) {
        this.score = score;
    }
    public float getScore() {
        return score;
    }
}

public class ParamTest {
    public static void main(String[] args) {
        Student stu = new Student(80);
        raiseScore(stu);
        System.out.print(stu.getScore());    //【运行结果】：90
    }

    public static void raiseScore(Student s) {
        s.setScore(s.getScore() + 10);
    }
}
</code></pre><h4 id="过程解析-1"><a href="#过程解析-1" class="headerlink" title="过程解析"></a>过程解析</h4><ul>
<li>s被赋予stu值的拷贝，这里是一个对象的引用</li>
<li>raiseScore方法应用于这个应用。s和stu指向同一对象，该对象的分数增加了10</li>
<li>raiseScore方法结束后，s不再使用，stu指向的那个对象分数增加了10</li>
</ul>
<p><img src="/post_image/java-chuandi/yinyongchuandi.jpg" alt="yinyongchuandi"></p>
<h3 id="为什么说Java没有引用传递"><a href="#为什么说Java没有引用传递" class="headerlink" title="为什么说Java没有引用传递"></a>为什么说Java没有引用传递</h3><pre><code>class Student {

    private float score;

    public Student(float score) {
        this.score = score;
    }

    public void setScore(float score) {
        this.score = score;
    }

    public float getScore() {
        return score;
    }
}

public class ParamTest {
    public static void main(String[] args) {
        Student a = new Student(0);
        Student b = new Student(100);

        System.out.println(&quot;交换前：&quot;);        
        System.out.println(&quot;a的分数：&quot; + a.getScore() + &quot;--- b的分数：&quot; + b.getScore());        //【运行结果】：a的分数：0.0--- b的分数：100.0

        swap(a, b);

        System.out.println(&quot;交换后：&quot;);
        System.out.println(&quot;a的分数：&quot; + a.getScore() + &quot;--- b的分数：&quot; + b.getScore());        //【运行结果】：a的分数：0.0--- b的分数：100.0
    }

    public static void swap(Student x, Student y) {
        Student temp = x;
        x = y;
        y = temp;
    }
}
</code></pre><p>可以看出，上述代码运行后，a，b并没有实现交换。</p>
<h4 id="过程解析-2"><a href="#过程解析-2" class="headerlink" title="过程解析"></a>过程解析</h4><p><img src="/post_image/java-chuandi/swap1.jpg" alt="swap1"><br><img src="/post_image/java-chuandi/swap2.jpg" alt="swap2"><br><img src="/post_image/java-chuandi/swap3.jpg" alt="swap3"></p>
<p>从这个过程中可以看出，<strong>严格来讲，Java采用的不是引用调用</strong>。实际上，对象引用进行的是值传递，只不过是传递的对象的地址。</p>
<p><strong>Java中引用传递更类似 C++ 中指针作为参数</strong>. C++ 中指针是一个变量，只不过这个变量存储的是一个地址，指向内存的一个存储单元；而引用跟原来的变量实质上是同一个东西，只不过是原变量的一个别名而已.</p>
<p>总结一下java中方法参数的使用情况：</p>
<ul>
<li>一个方法不能修改一个基本数据类型的参数(即数值型和布尔型)</li>
<li>一个方法可以改变一个对象中变量的值</li>
<li>一个方法不能让对象参数引用一个新的对象</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Java值传递&quot;&gt;&lt;a href=&quot;#Java值传递&quot; class=&quot;headerlink&quot; title=&quot;Java值传递&quot;&gt;&lt;/a&gt;Java值传递&lt;/h3&gt;&lt;p&gt;指的是在方法调用时，传递的参数是按值的拷贝传递。此时内存中存在&lt;strong&gt;两个&lt;/strong&gt;相等的基本类型，即实际参数和形式参数，后面方法中的操作都是对形参这个值的修改，不影响实际参数的值.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class ParamTest {
    public static void main(String[] args) {
        int price = 5;
        doubleValue(price);
        System.out.print(price);    //【输出结果】: 5
    }

    public static void doubleValue(int x) {
        x = 2 * x;
    }
}
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="Tech" scheme="http://mjackie.github.io/categories/Tech/"/>
    
    
      <category term="java" scheme="http://mjackie.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Data Matrix 解析算法</title>
    <link href="http://mjackie.github.io/Tech/cj6nko88w00166l5k9dtcr55o/"/>
    <id>http://mjackie.github.io/Tech/cj6nko88w00166l5k9dtcr55o/</id>
    <published>2017-05-27T05:00:00.000Z</published>
    <updated>2017-07-31T11:28:12.095Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Data-Matrix"><a href="#Data-Matrix" class="headerlink" title="Data Matrix"></a>Data Matrix</h3><p>Data Matrix 是二维码的一种编码格式，原名Data code，由美国国际资料公司(International Data Matrix, 简称ID Matrix)于1989年发明。</p>
<p>Data Matrix二维条码的外观是一个由许多小方格所组成的正方形或长方形符号，以二位元码(Binary-code)方式来编码。深色代表“1”，浅色代表“0”。</p>
<p>定位图形是资料区域的一个周界，为一个模组宽度。其中两条邻边为暗实线，主要用于限定物理尺寸；定位和符号失真。另两条邻边由交替的深色和浅色模组组成，主要用于限定符号的单元结构，但也能帮助确定物理尺寸及失真。</p>
<p><img src="/post_image/datamatrix/datamatrix.png" alt="datamatrix"><br><a id="more"></a></p>
<h3 id="Data-Matrix-检测算法"><a href="#Data-Matrix-检测算法" class="headerlink" title="Data Matrix 检测算法"></a>Data Matrix 检测算法</h3><p>之前文章我们已经介绍过二维码的解码流程，本篇文章主要介绍Data Matrix Detect 算法，也就是如何从一幅图片中找出符号码的部分。</p>
<p>Data Matrix 不同于有显示定位符的二维码，例如 QR 码。所以定位符号图像的方式较为低效，即从图像中心向四周搜索，直到框住整个符号图像。这种检测方式也限定了图像中心区域必须为符号图像，否则则会检测失败。</p>
<p>检测步骤分为如下几步：</p>
<ol>
<li><p><strong>大致划出符号图像的位置。</strong>从图像中间画一个小矩形框，然后依次向四边推行，检测四边上是否有黑色的点，直到每一边都没有黑色的点为止。</p>
<p> 最终检测完四条边就会得到符号图像的大致位置。<br> <img src="/post_image/datamatrix/datamatrix2.jpg" alt="datamatrix2"></p>
</li>
<li><p><strong>找寻符号图像四个顶点。</strong>大致范围确定以后就需要确定符号图像四个角的顶点，有了四个角的顶点就可以进行透视变换，符号码图像也就能够取出。首先在大检测框的四个角用斜45度的直线去检测，如下图所示：</p>
<p> <img src="/post_image/datamatrix/datamatrix3.jpg" alt="datamatrix3"></p>
</li>
<li><p><strong>确定顶点方位和纬度。</strong><br>DataMatrix符号图像边缘的一圈成两个L形，一个L是实线，一个L是虚线。搜索的方法就是沿4条边的直线进行黑白变换次数的检测。黑白变换次数少的就是实线的边，多的就是虚线的边，再去找两个L形的交点，就确定了左下角和右上角这两点，然后再经过两点间距离的比较确定出四个顶点。</p>
<p> <img src="/post_image/datamatrix/datamatrix4.jpg" alt="datamatrix4"></p>
<p> 纬度就是符号的一边上有多少个模块，计算方法就是去找虚线定位符那一边有多少次黑白变换（DataMatrix的纬度都是偶数，所以要进行误差修正）。纬度计算出来了就可以知道每个模块的宽度，再由此就可以计算出四条边分别有多少个模块。这样就可以计算出符号的长宽比，就能够确定是长方形还是正方形。</p>
</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Data-Matrix&quot;&gt;&lt;a href=&quot;#Data-Matrix&quot; class=&quot;headerlink&quot; title=&quot;Data Matrix&quot;&gt;&lt;/a&gt;Data Matrix&lt;/h3&gt;&lt;p&gt;Data Matrix 是二维码的一种编码格式，原名Data code，由美国国际资料公司(International Data Matrix, 简称ID Matrix)于1989年发明。&lt;/p&gt;
&lt;p&gt;Data Matrix二维条码的外观是一个由许多小方格所组成的正方形或长方形符号，以二位元码(Binary-code)方式来编码。深色代表“1”，浅色代表“0”。&lt;/p&gt;
&lt;p&gt;定位图形是资料区域的一个周界，为一个模组宽度。其中两条邻边为暗实线，主要用于限定物理尺寸；定位和符号失真。另两条邻边由交替的深色和浅色模组组成，主要用于限定符号的单元结构，但也能帮助确定物理尺寸及失真。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/post_image/datamatrix/datamatrix.png&quot; alt=&quot;datamatrix&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="Tech" scheme="http://mjackie.github.io/categories/Tech/"/>
    
    
      <category term="二维码" scheme="http://mjackie.github.io/tags/%E4%BA%8C%E7%BB%B4%E7%A0%81/"/>
    
      <category term="算法" scheme="http://mjackie.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>ccnSim 模拟器</title>
    <link href="http://mjackie.github.io/Tech/cj6nko88y00196l5kdfzaypku/"/>
    <id>http://mjackie.github.io/Tech/cj6nko88y00196l5kdfzaypku/</id>
    <published>2017-04-08T13:22:00.000Z</published>
    <updated>2017-08-15T13:16:05.512Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要解析 ccnSim 的架构及源码包各文件作用，关于 ccnSim 的各项配置参数，安装方法等 manual 文档中已介绍的内容本文不再介绍。</p>
<h2 id="什么是-ccnSim"><a href="#什么是-ccnSim" class="headerlink" title="什么是 ccnSim"></a>什么是 ccnSim</h2><p>ccnSim 是一个可扩展 chunk-level 的网络模拟器，基于OMNeT++框架，使用 C + + 编写，允许在大数量级的场景下模拟 CCN 网络。<br>ccnSim 模拟步骤以下三个阶段：</p>
<ul>
<li>编译 ccnSim 源文件， 链接 Omnet + + 框架</li>
<li>编写拓扑描述(通常用户只需要设置 CCN 节点之间的连接)</li>
<li>初始化每个模块的参数。这个可以直接读取 ned 文件或者 omnetpp.ini 初始化文件。</li>
<li>执行仿真</li>
</ul>
<a id="more"></a>
<h2 id="OMNeT-简介"><a href="#OMNeT-简介" class="headerlink" title="OMNeT ++ 简介"></a>OMNeT ++ 简介</h2><p>既然想要读懂 ccnSim 的代码，首先要对 Omnet++ 有所了解。OMNeT++是一个免费的、开源的多协议网络仿真软件，在网络仿真领域中占有十分重要的地位。</p>
<ul>
<li>OMNeT + + 是基于模块化的，最底层不可分割的模块是简单模块（ simple modules），简单模块可以组成复合模块（ compound modules）。</li>
<li>在 OMNeT + + 平台上，用户使用 NED 语言来定义组件的结构，一般一个组件（.h 和其对应的 .cc 文件）同时对应一个.net文件</li>
<li>组件之间通过 Message 进行交互，<code>handleMessage()</code> 方法用来处理消息</li>
</ul>
<p>不了解 Omnet++ 的可以先读一下软件的 Manual 文档和软件包中附带的 tictoc 示例代码</p>
<h2 id="ccnSim-架构"><a href="#ccnSim-架构" class="headerlink" title="ccnSim 架构"></a>ccnSim 架构</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>在了解相应代码之前，我们首先需要了解一下 ccnSim 作者在面向对象编程时的思路。</p>
<ul>
<li>网络由各个节点组成，每个节点都是一个 <code>core_layer</code> 对象，<code>core_layer</code> 又包含了 <code>base_cache</code> 和 <code>strategy_layer</code> 两个对象。</li>
<li>每个节点可以连接0个或1个 client ,client 代表一组用户，可以向网络发起内容请求。</li>
<li>用户可以在配置文件中设置相关的仿真参数，决定相应的缓存策略，路由策略<br><img src="/post_image/ccnSim.png" alt="ccnSim"></li>
</ul>
<h3 id="目录，核心文件介绍"><a href="#目录，核心文件介绍" class="headerlink" title="目录，核心文件介绍"></a>目录，核心文件介绍</h3><ul>
<li>include: 包含程序的头文件，多数.h文件对应 src 文件夹下的 .cc 文件<ul>
<li>ccnsim.h 是程序的入口文件，定义了一些全部变量，数据结构及相应的处理方法</li>
<li>需要注意的是<strong>缓存决策</strong>方法的源代码文件都在此目录下，直接在.h文件中定义了方法，没有与之对应的 src 文件。例如 ProbCache 算法对应 <code>prob_cache.h</code> 文件，LCD 算法对应 <code>lcd_policy.h</code> 文件</li>
</ul>
</li>
<li>modules： 模型文件（.ned）目录，所有的模型都由三个文件组成（<code>.ned</code>模型文件，<code>.h</code>声明文件，<code>.cc</code>源代码文件），目录结构与 src 一样，在 src 目录下统一介绍</li>
<li>networks：测试用的网络拓扑结构文件（<code>.ned</code>）目录</li>
<li>packets： 定义的交换信息格式文件存放的目录。定义时仅需定义 <code>.msg</code> 文件，对应的 <code>.cc</code> 和 <code>.h</code> 文件会在编译时自动产生</li>
<li>results 仿真实验结果数据存放目录</li>
<li>src 源代码目录<ul>
<li>clients <ul>
<li><code>client.cc</code> 定义 client 对象，client 会发起请求，处理返回的 data 数据，以及相应的数据统计</li>
</ul>
</li>
<li>content<ul>
<li><code>content_distribution.cc</code>  实现了内容初始化。初始化内容源仓库，内容分配等</li>
<li><code>zipf.cc</code> 实现内容 zipf 分布</li>
</ul>
</li>
<li>node<ul>
<li>cache ： 替换算法目录<ul>
<li><code>base_cache.cc</code>: base_cache 对象作为节点缓存空间的承载体，是<strong>其他缓存替换算法的父类</strong>。实现了缓存存取，查找的功能。</li>
<li><code>fifo_cache.cc</code>： 先进先出替换算法</li>
<li><code>lru_cache.cc</code>: 近期最少使用替换算法</li>
<li><code>random_cache.cc</code>: 随机替换算法</li>
</ul>
</li>
<li>strategy： 路由策略代码目录<ul>
<li><code>strategy_layer.cc</code>： 路由算法的父类，初始化FIB</li>
<li><code>MonopathStrategyLayer.cc</code>： 继承自<code>strategy_layer.cc</code> <strong>多数路由算法继承此类</strong>定义了路径选择方法等</li>
<li><code>spr.cc</code> ： 最近路由策略算法，将请求路由至最近的内容源仓库</li>
</ul>
</li>
<li><code>core_layer.cc</code>: <strong>节点的承载对象</strong>，处理请求（interest）与数据（data）</li>
</ul>
</li>
<li>statistics<ul>
<li><code>statistics.cc</code>: 统计代码，定义了统计规则，对仿真进行数据统计</li>
</ul>
</li>
</ul>
</li>
<li><code>omnetpp.ini</code>： 仿真配置文件，omnetpp 的配置文件语法规则</li>
</ul>
<h3 id="请求内容"><a href="#请求内容" class="headerlink" title="请求内容"></a>请求内容</h3><p>client 通过生成一个0到1的随机数，通过zipf函数，得到该分布概率下的最有一个内容。如果把内容按热度排序，那么从1到n的热度内容概率分布是这个随机数，n就是要发起请求的内容。<br>INTEREST 中的 chunk 由 id + number 组成，第一个 number 为0</p>
<h3 id="LRU-替换算法"><a href="#LRU-替换算法" class="headerlink" title="LRU 替换算法"></a>LRU 替换算法</h3><p>LRU 替换算法通过一个哈希表和一个双向链表实现。哈希表记录内容号，用于快速查找。双向链表通过两个指针分别记录刚被使用的和最久未被使用的。</p>
<pre><code>lru_pos* lru; //least recently used item
lru_pos* mru; //most recently used item
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要解析 ccnSim 的架构及源码包各文件作用，关于 ccnSim 的各项配置参数，安装方法等 manual 文档中已介绍的内容本文不再介绍。&lt;/p&gt;
&lt;h2 id=&quot;什么是-ccnSim&quot;&gt;&lt;a href=&quot;#什么是-ccnSim&quot; class=&quot;headerlink&quot; title=&quot;什么是 ccnSim&quot;&gt;&lt;/a&gt;什么是 ccnSim&lt;/h2&gt;&lt;p&gt;ccnSim 是一个可扩展 chunk-level 的网络模拟器，基于OMNeT++框架，使用 C + + 编写，允许在大数量级的场景下模拟 CCN 网络。&lt;br&gt;ccnSim 模拟步骤以下三个阶段：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;编译 ccnSim 源文件， 链接 Omnet + + 框架&lt;/li&gt;
&lt;li&gt;编写拓扑描述(通常用户只需要设置 CCN 节点之间的连接)&lt;/li&gt;
&lt;li&gt;初始化每个模块的参数。这个可以直接读取 ned 文件或者 omnetpp.ini 初始化文件。&lt;/li&gt;
&lt;li&gt;执行仿真&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Tech" scheme="http://mjackie.github.io/categories/Tech/"/>
    
    
      <category term="icn" scheme="http://mjackie.github.io/tags/icn/"/>
    
      <category term="c++" scheme="http://mjackie.github.io/tags/c/"/>
    
      <category term="c" scheme="http://mjackie.github.io/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>网站作品展示</title>
    <link href="http://mjackie.github.io/Tech/cj6nko89o001v6l5kk227zi1n/"/>
    <id>http://mjackie.github.io/Tech/cj6nko89o001v6l5kk227zi1n/</id>
    <published>2017-01-02T16:00:00.000Z</published>
    <updated>2017-07-31T13:21:59.379Z</updated>
    
    <content type="html"><![CDATA[<p>总结了一下大学做的一些网站工作。后台统一是学校的站群，所以工作主要集中在前端。民生学院作为河南大学的独立学院，宣传部的网站制作与维护工作都交给了我们实验室。统计了一下，自己独立完成的一共大概有十几个。虽然工作技术难度不大，不过在实践中还是学到了很多东西。</p>
<h5 id="民生学院财务部"><a href="#民生学院财务部" class="headerlink" title="民生学院财务部"></a>民生学院财务部</h5><p><img src="/post_image/web-zuopin/caiwubu.jpg" alt="image"><br><a id="more"></a></p>
<h5 id="支教邦"><a href="#支教邦" class="headerlink" title="支教邦"></a>支教邦</h5><p><img src="/post_image/web-zuopin/zhijiaobang.png" alt="image"><br><!--more--></p>
<h5 id="特种功能材料重点实验室"><a href="#特种功能材料重点实验室" class="headerlink" title="特种功能材料重点实验室"></a>特种功能材料重点实验室</h5><p><img src="/post_image/web-zuopin/cailiaolab.png" alt="image"></p>
<h5 id="民生学院人力资源部"><a href="#民生学院人力资源部" class="headerlink" title="民生学院人力资源部"></a>民生学院人力资源部</h5><p><img src="/post_image/web-zuopin/renliiziyuan.png" alt="image"></p>
<h5 id="民生学院纪检监察网"><a href="#民生学院纪检监察网" class="headerlink" title="民生学院纪检监察网"></a>民生学院纪检监察网</h5><p><img src="/post_image/web-zuopin/jijianjiancha.png" alt="image"></p>
<h5 id="艺术传媒学院"><a href="#艺术传媒学院" class="headerlink" title="艺术传媒学院"></a>艺术传媒学院</h5><p><img src="/post_image/web-zuopin/yishuchuanmei.png" alt="image"></p>
<h5 id="医学院"><a href="#医学院" class="headerlink" title="医学院"></a>医学院</h5><p><img src="/post_image/web-zuopin/yixueyuan.png" alt="image"></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;总结了一下大学做的一些网站工作。后台统一是学校的站群，所以工作主要集中在前端。民生学院作为河南大学的独立学院，宣传部的网站制作与维护工作都交给了我们实验室。统计了一下，自己独立完成的一共大概有十几个。虽然工作技术难度不大，不过在实践中还是学到了很多东西。&lt;/p&gt;
&lt;h5 id=&quot;民生学院财务部&quot;&gt;&lt;a href=&quot;#民生学院财务部&quot; class=&quot;headerlink&quot; title=&quot;民生学院财务部&quot;&gt;&lt;/a&gt;民生学院财务部&lt;/h5&gt;&lt;p&gt;&lt;img src=&quot;/post_image/web-zuopin/caiwubu.jpg&quot; alt=&quot;image&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="Tech" scheme="http://mjackie.github.io/categories/Tech/"/>
    
    
  </entry>
  
  <entry>
    <title>Blogecho, My Theme for Typecho</title>
    <link href="http://mjackie.github.io/Tech/cj6nko82a00006l5kfu3lzlpn/"/>
    <id>http://mjackie.github.io/Tech/cj6nko82a00006l5kfu3lzlpn/</id>
    <published>2016-12-05T01:21:00.000Z</published>
    <updated>2017-07-31T12:17:06.019Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://github.com/mJackie/Typecho-Theme-Blogecho/raw/master/githubimg/blogecho.jpg" alt="image"></p>
<h4 id="Blogecho-for-Typecho-概述"><a href="#Blogecho-for-Typecho-概述" class="headerlink" title="Blogecho for Typecho 概述"></a>Blogecho for Typecho 概述</h4><ul>
<li>作者：JackieLiu</li>
<li>版本：v1.0</li>
<li>更新日期：2016.11.28<a id="more"></a>
<h4 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h4><ol>
<li>集成代码高亮</li>
<li>完美兼容 MarkDown 语法</li>
<li>响应式布局</li>
<li>随机更换透明背景壁纸</li>
</ol>
</li>
</ul>
<h4 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h4><ol>
<li>点击 download zip 下载最新源码，解压，将其中文件夹重命名为 Blogecho 并上传至博客的 /usr/themes 目录下</li>
<li>可将img文件夹下 background 背景图片替换为自习喜欢的，logo.jpg 替换为自己的 logo 头像</li>
<li>在主题外观设置页面，设置相应选项</li>
<li>在博客后台点击启用</li>
</ol>
<h4 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h4><p>体验 Blogecho 主题: <a href="https://jackieliu.win" target="_blank" rel="external">Blogecho 演示</a></p>
<blockquote>
<p>注意：此演示基于 Hexo，与 Typechoe 有些许差异。</p>
</blockquote>
<h4 id="预览"><a href="#预览" class="headerlink" title="预览"></a>预览</h4><p><img src="https://github.com/mJackie/Typecho-Theme-Blogecho/raw/master/githubimg/blogecho2.png" alt="image"></p>
<p><img src="https://github.com/mJackie/Typecho-Theme-Blogecho/raw/master/githubimg/blogechoForTypechoSetup.png" alt="image"></p>
<h4 id="更新日志"><a href="#更新日志" class="headerlink" title="更新日志"></a>更新日志</h4><ul>
<li>2016.11.28  发布 Blogecho for Typecho v1.0</li>
</ul>
<h4 id="License"><a href="#License" class="headerlink" title="License"></a>License</h4><p>Open sourced under the MIT license.</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://github.com/mJackie/Typecho-Theme-Blogecho/raw/master/githubimg/blogecho.jpg&quot; alt=&quot;image&quot;&gt;&lt;/p&gt;
&lt;h4 id=&quot;Blogecho-for-Typecho-概述&quot;&gt;&lt;a href=&quot;#Blogecho-for-Typecho-概述&quot; class=&quot;headerlink&quot; title=&quot;Blogecho for Typecho 概述&quot;&gt;&lt;/a&gt;Blogecho for Typecho 概述&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;作者：JackieLiu&lt;/li&gt;
&lt;li&gt;版本：v1.0&lt;/li&gt;
&lt;li&gt;更新日期：2016.11.28
    
    </summary>
    
      <category term="Tech" scheme="http://mjackie.github.io/categories/Tech/"/>
    
    
      <category term="blog" scheme="http://mjackie.github.io/tags/blog/"/>
    
      <category term="typecho" scheme="http://mjackie.github.io/tags/typecho/"/>
    
  </entry>
  
  <entry>
    <title>SignalR框架</title>
    <link href="http://mjackie.github.io/Tech/cj6nko89f001l6l5kjwn12jeb/"/>
    <id>http://mjackie.github.io/Tech/cj6nko89f001l6l5kjwn12jeb/</id>
    <published>2016-12-04T12:13:00.000Z</published>
    <updated>2017-07-24T13:16:11.703Z</updated>
    
    <content type="html"><![CDATA[<p>ASP .NET SignalR 是为 ASP .NET 开发人员提供的一个库，可以简化开发人员将实时 Web 功能添加到应用程序的过程。实时 Web 功能是指这样一种功能：当所连接的客户端变得可用时服务器代码可以立即向其推送内容，而不是让服务器等待客户端请求新的数据。</p>
<p>前端 JS 需要引入，且 <code>/signalr/hubs</code> 必须在 <code>/Scripts/jquery.signalR-2.1.0.js</code> 之后引入</p>
<a id="more"></a>
<pre><code>&lt;!--Reference the jQuery library. --&gt;
&lt;script src=&quot;/Scripts/jquery-1.10.2.min.js&quot; &gt;&lt;/script&gt;
&lt;!--Reference the SignalR library. --&gt;
&lt;script src=&quot;/Scripts/jquery.signalR-2.1.0.js&quot;&gt;&lt;/script&gt;
&lt;!--Reference the autogenerated SignalR hub script. --&gt;
&lt;script src=&quot;/signalr/hubs&quot;&gt;&lt;/script&gt;
</code></pre><p>该框架通过 Hub 实例与客户端建立连接，一个 Hub 实例对应一个连接。在Hub中声明的方法，前端JS可直接进行调用，完成与服务器的交互。服务端也可直接调用客户端方法。</p>
<pre><code>namespace CMD.Controllers
{
    [HubName(&quot;sRadarHub&quot;)]     //前端js通过此名称调用
    public class SingleRadarHub:Hub
    {
         private readonly SingleRadar _sRadar;

         public SingleRadarHub() : this(SingleRadar.Instance) { }

         public SingleRadarHub(SingleRadar sRadar)
        {
            _sRadar = sRadar;
        }

        public DataOfSingleRadar GetAllDatas()
        {
            return _sRadar.GetAllDatas();
        }
    }
}
</code></pre><p>客户端调用服务端方法</p>
<pre><code>$(document).ready(function(){


    //SignalR连接建立--jackieliu  2016.10.04  
    var rHub = $.connection.sRadarHub;   //拿到连接


    function init() {//建立连接成功后走的代码
        rHub.server.getAllDatas().done(function (datas){//调用服务器端getAllDatas()方法，返回的数据类型为DataOfSingleRadar

           //开始数据处理

    }


    rHub.client.clientUpdateDatas = function (newdata) {
        //更新数据方法，供服务端调用   
        //newdata为服务端调用时的参数，包含数据信息

        //处理代码省略，对newdata进行解析显示即可

    }


    $.connection.hub.start().done(init);


});
</code></pre><p>服务端调用客户端方法</p>
<pre><code>private IHubConnectionContext&lt;dynamic&gt; Clients
{
    get;
    set;
}

private void BroadcastDatas(DataOfSingleRadar datas)
{
    Clients.All.clientUpdateDatas(datas);   //clientUpdateDatas是客户端声明的方法
}
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;ASP .NET SignalR 是为 ASP .NET 开发人员提供的一个库，可以简化开发人员将实时 Web 功能添加到应用程序的过程。实时 Web 功能是指这样一种功能：当所连接的客户端变得可用时服务器代码可以立即向其推送内容，而不是让服务器等待客户端请求新的数据。&lt;/p&gt;
&lt;p&gt;前端 JS 需要引入，且 &lt;code&gt;/signalr/hubs&lt;/code&gt; 必须在 &lt;code&gt;/Scripts/jquery.signalR-2.1.0.js&lt;/code&gt; 之后引入&lt;/p&gt;
    
    </summary>
    
      <category term="Tech" scheme="http://mjackie.github.io/categories/Tech/"/>
    
    
      <category term=".net" scheme="http://mjackie.github.io/tags/net/"/>
    
  </entry>
  
  <entry>
    <title>js调用.net视图页model的问题</title>
    <link href="http://mjackie.github.io/Tech/cj6nko895001d6l5k1zmp5wku/"/>
    <id>http://mjackie.github.io/Tech/cj6nko895001d6l5k1zmp5wku/</id>
    <published>2016-11-28T10:03:00.000Z</published>
    <updated>2017-07-31T11:30:17.123Z</updated>
    
    <content type="html"><![CDATA[<p>做项目用到折线图，简单看了下 Chart.js 的文档，Chart.js 采用 js 对图表进行赋值。后台 .net Controller 返回带有 model 参数的视图页面，网上查了下js获取 .net 视图页 model<br>的方法如下：</p>
<pre><code>alert(&apos;@Model&apos;);    #输出对象类型
alert(&apos;@Model.strarr&apos;);    #输出字符串 System.String[]
alert(&apos;@Model.strarr[0]&apos;);    #输出strarr[0]的值
</code></pre><p>无法遍历Model中数组的值，无法采用变量 i 来拼接 ‘@Model.strarr[i]’ </p>
<a id="more"></a>
<h4 id="解决办法："><a href="#解决办法：" class="headerlink" title="解决办法："></a>解决办法：</h4><p>先将Model的值输出到页面的表格上，再用js取出表格的数据，赋值给折线图</p>
<h4 id="主要代码"><a href="#主要代码" class="headerlink" title="主要代码"></a>主要代码</h4><pre><code>&lt;tr&gt;
    &lt;td&gt;&lt;button class=&quot;btn&quot; style=&quot;background:black&quot;&gt;&lt;/button&gt; 20分钟 &lt;/td&gt;
    @foreach (var s20 in Model.s20minAssessmentData)
    {
        &lt;th name=&quot;s20&quot;&gt;@s20&lt;/th&gt;
    }
&lt;/tr&gt;
&lt;tr&gt;

&lt;script&gt;
var ctx = document.getElementById(&quot;myChart&quot;).getContext(&quot;2d&quot;);
var pretime = document.getElementsByName(&quot;pre-time&quot;);
for (var i=0 ; i &lt; pretime.length; i++) {
     data.labels.push(pretime[i].innerText);
}
chartLine = new Chart(ctx).Line(data);
&lt;/script&gt;
</code></pre><h4 id="附：js判断对象是否为空的三种方式"><a href="#附：js判断对象是否为空的三种方式" class="headerlink" title="附：js判断对象是否为空的三种方式"></a>附：js判断对象是否为空的三种方式</h4><pre><code>if   (typeOf(x)   ==   &quot;undefined&quot;)
if   (typeOf(x)   !=   &quot;object&quot;)
if(!x)
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;做项目用到折线图，简单看了下 Chart.js 的文档，Chart.js 采用 js 对图表进行赋值。后台 .net Controller 返回带有 model 参数的视图页面，网上查了下js获取 .net 视图页 model&lt;br&gt;的方法如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;alert(&amp;apos;@Model&amp;apos;);    #输出对象类型
alert(&amp;apos;@Model.strarr&amp;apos;);    #输出字符串 System.String[]
alert(&amp;apos;@Model.strarr[0]&amp;apos;);    #输出strarr[0]的值
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;无法遍历Model中数组的值，无法采用变量 i 来拼接 ‘@Model.strarr[i]’ &lt;/p&gt;
    
    </summary>
    
      <category term="Tech" scheme="http://mjackie.github.io/categories/Tech/"/>
    
    
      <category term="javascript" scheme="http://mjackie.github.io/tags/javascript/"/>
    
      <category term=".net" scheme="http://mjackie.github.io/tags/net/"/>
    
  </entry>
  
  <entry>
    <title>Blog重建手记</title>
    <link href="http://mjackie.github.io/Tech/cj6nko87o00096l5kpbt0w06u/"/>
    <id>http://mjackie.github.io/Tech/cj6nko87o00096l5kpbt0w06u/</id>
    <published>2016-11-26T14:03:00.000Z</published>
    <updated>2017-07-24T09:42:19.612Z</updated>
    
    <content type="html"><![CDATA[<p>也记不清SAE从何时开始不送云豆，自己所剩的1万云豆就逐渐的消耗，中间还有一次被莫名攻击，一天掉了几千豆。加上自己也不知道该写点什么来发布，博客一直处于停摆状态。<br>9月底保研结束，时间也较为充裕，又萌生了持续更新博文的想法。在博客重新搭建的过程中也思考了如下问题：</p>
<h4 id="CMS的选择"><a href="#CMS的选择" class="headerlink" title="CMS的选择"></a>CMS的选择</h4><ul>
<li>Wordpress 是目前最为流行的 PHP 开发的博客平台，优点是配套的资源（主题、插件等）众多、功能丰富、安装方式简单易用。但对于仅仅发些文章的人来说，Wordpress 显得有些臃肿。<a id="more"></a></li>
<li><p>Typecho 也是基于 PHP 的开源博客平台，轻量高效，简洁友好。正如 Typecho 的初衷和正在做的一样，做得不多，但足够好。Typecho 默认编辑器采用 MarkDown 排版语法。对比 Wordpress 来说，在主题以及插件数量上有着明显的不足。</p>
</li>
<li><p>Jekyll 是一个基于 Ruby 简单的免费的Blog生成工具，但是和前两种有很大的不同，原因是 Jekyll 只是一个生成静态网页的工具，不需要数据库支持，Jekyll 可以免费部署在 Github 上。用户将写好的 Markdown 文件直接 Push 到自己的 repository, GitHub Pages 便会自动将 Markdown 文件解析为对应的 静态 Html 文件，供访问浏览。Jekyll 部署调试相当复杂，官方文档不推荐本地 Windows 环境，对于分类、tag 等的操作也很复杂。</p>
</li>
<li><p>Hexo 是基于 Node.js 的静态博客框架，出自台湾大学生 SkyArrow 之手。Hexo 简化了操作流程，有四大特点：极速生成静态页面、支持Markdown、一键部署博客、丰富的主题插件支持。Hexo 与 Jekyll 最大的不同之处在于 <code>hexo deploy</code> 命令是将本地的public文件夹（生成的静态html）Push 到了repository，而 Jekyll 是将整个项目都托管到了 GitHub 上。</p>
<blockquote>
<p>在对比了多种 CMS 的优缺点后，根据自身需求选择了Hexo。首先是因为平时有用Markdown记录笔记的习惯<br>；再者采用 Hexo + GitHub 的组合实现了一劳永逸的解决办法，不用再为主机空间发愁；这样平时在有道云笔记中的笔记需要发布时加上头信息直接导出来就行了。</p>
</blockquote>
</li>
</ul>
<h4 id="主题风格的设计"><a href="#主题风格的设计" class="headerlink" title="主题风格的设计"></a>主题风格的设计</h4><p>主题在设计前先明确了下自己的需求：</p>
<ul>
<li>设计风格简洁、干净、清晰化一</li>
<li>响应式布局</li>
<li>代码高亮</li>
<li>支持Markdown<blockquote>
<p>在主题的制作过程中发现制作 Hexo 主题，除了需要了解 HTML / CSS / JavaScript 之外，还需要了解两个主要的技术，首先一个是模板引擎，Hexo支持主流的模板引擎，像 EJS / Jade / Swig 等，另外一个是 CSS 预处理，如 SASS / LESS / Stylus 。当然，对于我这种菜鸟来说，这两个我都不会，也懒得学，就直接采用了 HTML / CSS 在默认主题 landscape 上做修改 ，效率低了一点，不过最终还是完成了制作。</p>
</blockquote>
</li>
</ul>
<h4 id="图片保存路径"><a href="#图片保存路径" class="headerlink" title="图片保存路径"></a>图片保存路径</h4><p>对于 Markdown 来说，添加图片一直存在一些弊端，一种方法是建立图片文件夹保存在文档目录，采用相对路径进行引用，但这样无法满足发布博文的需求。另一种方法是将图片上传到网上，用url进行引用。在图床的选择上可以用微博相册/GitHub仓库等等，最终我选择了七牛云存储。七牛云为普通用户提供了免费的10GB空间，对于仅仅作为笔记插图的我来收也足够使用，七牛云也较为稳定。</p>
<h4 id="域名绑定"><a href="#域名绑定" class="headerlink" title="域名绑定"></a>域名绑定</h4><p>GitHub Pages 不支持多域名绑定，且不支持泛解析。仅支持以下4种绑定方式：<br><img src="/post_image/GithubPagesDomain.JPG" alt="image"><br>若将域名泛解析到 GitHub Pages 上，可能导致其他人使用你的某个子域名作为其绑定域名。<br>repository 中的 CNAME 文件内容指定了绑定的域名。<br>尝试在 repository 中的 CNAME 文件中加入两个不同域名，结果只有第一行起作用，因此不支持多域名绑定。</p>
<p>域名 <code>JackieLiu.win</code> 是在万网买的，29块买了10年，真的好便宜。在万网解析不了，DS转到了DNSPod，做了两条 CNAME 分别将 <code>@</code> 和 <code>www</code> 指向了 <code>mjackie.github.io</code></p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>一个博客的好坏不是页面做的多好看，也不是用的技术多么的先进。博客的价值在于博客的<strong>内容</strong>。希望今后自己可以提高更博频率，一方面督促自己不断学习，另一方面可以提升自己的写作、总结能力。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;也记不清SAE从何时开始不送云豆，自己所剩的1万云豆就逐渐的消耗，中间还有一次被莫名攻击，一天掉了几千豆。加上自己也不知道该写点什么来发布，博客一直处于停摆状态。&lt;br&gt;9月底保研结束，时间也较为充裕，又萌生了持续更新博文的想法。在博客重新搭建的过程中也思考了如下问题：&lt;/p&gt;
&lt;h4 id=&quot;CMS的选择&quot;&gt;&lt;a href=&quot;#CMS的选择&quot; class=&quot;headerlink&quot; title=&quot;CMS的选择&quot;&gt;&lt;/a&gt;CMS的选择&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;Wordpress 是目前最为流行的 PHP 开发的博客平台，优点是配套的资源（主题、插件等）众多、功能丰富、安装方式简单易用。但对于仅仅发些文章的人来说，Wordpress 显得有些臃肿。
    
    </summary>
    
      <category term="Tech" scheme="http://mjackie.github.io/categories/Tech/"/>
    
    
      <category term="blog" scheme="http://mjackie.github.io/tags/blog/"/>
    
      <category term="typecho" scheme="http://mjackie.github.io/tags/typecho/"/>
    
      <category term="hexo" scheme="http://mjackie.github.io/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>词法分析器</title>
    <link href="http://mjackie.github.io/Tech/cj6nko8a9002g6l5kbhn60vnv/"/>
    <id>http://mjackie.github.io/Tech/cj6nko8a9002g6l5kbhn60vnv/</id>
    <published>2016-04-27T16:46:00.000Z</published>
    <updated>2016-11-25T14:29:40.189Z</updated>
    
    <content type="html"><![CDATA[<p>编译原理实验课写的词法分析器，加深了对编程语言的理解，将课本上的伪代码实现完善了一遍，纯手打。</p>
<pre><code>/* 编译原理实验-词法分析器
 * 刘嘉琦-20160325
 * 1、PL/0语言的单词结构
//关键字(10个)：begin, end ,if ,then, while, do, const, var,call,procedure
//标识符：字母序列，最大长度10
//常数：整型常数
//算符和界符（17个）：+， -， *，/，odd，=，&lt;&gt;，&lt;，&gt;，&lt;=，&gt;=，:=，(，) ，, ，.，;
//2、单词的种别划分
//    标识符 作为一种
//    常数 作为一种
//    算符和界符每个单词作为一个单独种别
//3、PL/0的语言的词法分析器将要完成以下工作：
//（1）    跳过分隔符（如空格，回车，制表符）；
//（2）    识别诸如begin，end，if，while等保留字；
//（3）    识别非保留字的一般标识符。
//（4）    识别数字序列。
//（5）    识别:=，&lt;=，&gt;=之类的特殊符号。
//4、词法分析器的实现方式：
//    把词法分析器设计成一个独立子程序，以便于语法分析器调用。词法分析器运行一次产生一个单词符号。
//5、词法分析器的输出形式
//   （种别，属性值）
//其中：种别在“2、单词的种别”中进行了定义；
//      属性值：若单词种别只代表唯一单词，属性值为空；
//              若单词种别是SYM_IDENTIFIER，属性值为该单词在标识符表中的位置；
//              若单词种别是SYM_ NUMBER，属性值为该单词在常数表中的位置。
**/
</code></pre><a id="more"></a>
<pre><code>package foc;

import java.util.Scanner;

public class cffxq {
    char ch;
    StringBuffer strToken;
    static int flag_getchar = 0; //搜索指示器
    String str;   //字符串
    String[] gjz = {&quot;odd&quot;,&quot;begin&quot;, &quot;end&quot; ,&quot;if&quot; ,&quot;then&quot;, &quot;while&quot;, &quot;do&quot;, &quot;const&quot;, &quot;var&quot;,&quot;call&quot;,&quot;procedure&quot;};
    String[][] chart_id = new String[100][2];
    int flag_id = 0; //标识符指针
    String[] chart_const = new String[100];
    int flag_const = 0; //常数指针

    public static void main(String[] args){
        Scanner sc = new Scanner(System.in);
        StringBuffer stb = new StringBuffer(sc.nextLine());
        stb.append(&quot; &quot;);
        String str = stb.toString();
        cffxq c = new cffxq();
        while(flag_getchar&lt;str.length()-1){
            c.begin(str);
        }

    }

    private void GetChar(){
        ch = str.charAt(flag_getchar);
        flag_getchar++;
    } 

    public void begin(String str) {
        this.str = str;

        int code,value;
        strToken = new StringBuffer(&quot;&quot;);
        GetChar();
        GetBC();
        if(IsLetter()){
            while(IsLetter()||IsDigit()){
                Concat();
                GetChar();
            }
            Retract();
            code = Reserve();
            if(code &lt; 0){
                value = InsertId(strToken.toString());
                System.out.println(&quot;($ID,&quot; + value +&quot;)&quot;);
                return;
            }
            else if(code == 0){
                System.out.println(&quot;(算符或界符,&quot; + &quot;odd&quot;+&quot;)&quot;); 
                return;
            }
            else{
                System.out.println(&quot;($&quot;+gjz[code]+&quot;,-)&quot; ); 
                return;
            }
        }

        else if(IsDigit()){
            while(IsDigit()){
                Concat();
                GetChar();
            }
            Retract();
            value = InsertConst(strToken.toString());
            System.out.println(&quot;($INT,&quot; + value +&quot;)&quot;);
            return;
        }

        else if(ch == &apos;+&apos;){
            System.out.println(&quot;($+,&quot; + &quot;-)&quot;);
            return;
        }
        else if(ch == &apos;-&apos;){
            System.out.println(&quot;($-,&quot; + &quot;-)&quot;);
            return;
        }
        else if(ch == &apos;*&apos;){
            System.out.println(&quot;($*,&quot; + &quot;-)&quot;);
            return;
        }
        else if(ch == &apos;/&apos;){
            System.out.println(&quot;($/,&quot; + &quot;-)&quot;);
            return;
        }
        else if(ch == &apos;=&apos;){
            System.out.println(&quot;($=,&quot; + &quot;-)&quot;);
            return;
        }
        else if(ch == &apos;,&apos;){
            System.out.println(&quot;($,,&quot; + &quot;-)&quot;);
            return;
        }
        else if(ch == &apos;.&apos;){
            System.out.println(&quot;($.,&quot; + &quot;-)&quot;);
            return;
        }
        else if(ch == &apos;(&apos;){
            System.out.println(&quot;($(,&quot; + &quot;-)&quot;);
            return;
        }
        else if(ch == &apos;)&apos;){
            System.out.println(&quot;($),&quot; + &quot;-)&quot;);
            return;
        }
        else if(ch == &apos;;&apos;){
            System.out.println(&quot;($;,&quot; + &quot;-)&quot;);
            return;
        }
        else if(ch == &apos;:&apos;){
            GetChar();
            if(ch == &apos;=&apos;){
                System.out.println(&quot;($:=,&quot; + &quot;-)&quot;);
                return;
            }
            Retract();
            System.out.println(&quot;($:,&quot; + &quot;-)&quot;);
        }
        else if(ch == &apos;&gt;&apos;){
            GetChar();
            if(ch == &apos;=&apos;){
                System.out.println(&quot;($&gt;=,&quot; + &quot;-)&quot;);
                return;
            }
            Retract();
            System.out.println(&quot;($&gt;,&quot; + &quot;-)&quot;);
            return;
        }
        else if(ch == &apos;&lt;&apos;){
            GetChar();
            if(ch == &apos;&gt;&apos;){
                System.out.println(&quot;($&lt;&gt;,&quot; + &quot;-)&quot;);
                return;
            }
            else if(ch == &apos;=&apos;){
                System.out.println(&quot;($&lt;=,&quot; + &quot;-)&quot;);
                return;
            }
            Retract();
            System.out.println(&quot;($&lt;,&quot; + &quot;-)&quot;);
            return;
        }

    }

    private void GetBC(){
        if(ch==&apos; &apos;){
            GetChar();
            GetBC();
        }
    }

    private void Concat(){
        strToken.append(ch);
    }

    private boolean IsLetter(){
        if(Character.isLetter(ch))
            return true;
        else
            return false;
    } 

    private boolean IsDigit(){
        if(Character.isDigit(ch))
            return true;
        else
            return false;
    } 

    private int Reserve(){
        for(int i=0;i&lt;gjz.length; i++){
            if(gjz[i].equals(strToken.toString()))
                return i;
        }
        return -1;   //返回数组索引，否则返回-1
    }

    private void Retract(){
        flag_getchar--;
        ch = &apos; &apos;;
    }

    private int InsertId(String strToken){
        for(int i=0;i&lt;flag_id;i++){
            if(chart_id[i][0].equals(strToken))
                return i;
        }
        chart_id[flag_id][0] = strToken;
        flag_id++;
        return flag_id-1;
    }

    private int InsertConst(String strToken){
        for(int i=0;i&lt;flag_const;i++){
            if(chart_const[i].equals(strToken))
                return i;
        }
        chart_const[flag_const] = strToken;
        flag_const++;
        return flag_const-1;
    }
    private void ProcError(){
        System.out.println(&quot;词法错误！&quot;);
    }

}
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;编译原理实验课写的词法分析器，加深了对编程语言的理解，将课本上的伪代码实现完善了一遍，纯手打。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/* 编译原理实验-词法分析器
 * 刘嘉琦-20160325
 * 1、PL/0语言的单词结构
//关键字(10个)：begin, end ,if ,then, while, do, const, var,call,procedure
//标识符：字母序列，最大长度10
//常数：整型常数
//算符和界符（17个）：+， -， *，/，odd，=，&amp;lt;&amp;gt;，&amp;lt;，&amp;gt;，&amp;lt;=，&amp;gt;=，:=，(，) ，, ，.，;
//2、单词的种别划分
//    标识符 作为一种
//    常数 作为一种
//    算符和界符每个单词作为一个单独种别
//3、PL/0的语言的词法分析器将要完成以下工作：
//（1）    跳过分隔符（如空格，回车，制表符）；
//（2）    识别诸如begin，end，if，while等保留字；
//（3）    识别非保留字的一般标识符。
//（4）    识别数字序列。
//（5）    识别:=，&amp;lt;=，&amp;gt;=之类的特殊符号。
//4、词法分析器的实现方式：
//    把词法分析器设计成一个独立子程序，以便于语法分析器调用。词法分析器运行一次产生一个单词符号。
//5、词法分析器的输出形式
//   （种别，属性值）
//其中：种别在“2、单词的种别”中进行了定义；
//      属性值：若单词种别只代表唯一单词，属性值为空；
//              若单词种别是SYM_IDENTIFIER，属性值为该单词在标识符表中的位置；
//              若单词种别是SYM_ NUMBER，属性值为该单词在常数表中的位置。
**/
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="Tech" scheme="http://mjackie.github.io/categories/Tech/"/>
    
    
  </entry>
  
  <entry>
    <title>关于党课学习系统</title>
    <link href="http://mjackie.github.io/Tech/cj6nko89i001s6l5k8jvojb3z/"/>
    <id>http://mjackie.github.io/Tech/cj6nko89i001s6l5k8jvojb3z/</id>
    <published>2016-04-15T14:19:00.000Z</published>
    <updated>2017-07-31T11:30:21.187Z</updated>
    
    <content type="html"><![CDATA[<p>学校让在线学习党课内容，想到之前学校的四六级报名系统就存在太多安全问题，可以下载全校的免冠照片，尝试着破解了一下党课学习系统<br>学习系统是要在网页中浏览指定的时间后才可以进行测试，一个章节有两个小时，有几十分钟的，并且每隔五分钟不移动鼠标就停止计时<br>将网页保存到本地后，发现了名为LearnControl.js的javascrip文件，找到了如下的一段代码</p>
<a id="more"></a>
<pre><code>$scope.saveLearnTime = function (learnTime, auto) {
    if ($scope.studentId != &quot;&quot;) {
        $http.get(servicePath + &apos;/ConditionService.ashx?method=SaveLearnTime&amp;&amp;learnTime=&apos; + learnTime).success(function (data) {
            console.log(&quot;保存时间：&quot; + data);
            if (!auto) {
                $scope.tishiMessage = &apos;保存学习时间成功!下次进入学习按&apos; + $scope.convertTime(data) + &apos;计时.&apos;;
                //$(&apos;#tishi&apos;).modal(&apos;toggle&apos;)
                alert($scope.tishiMessage);
                //alert(&apos;保存学习时间成功!下次进入学习按&apos; + $scope.convertTime(data) + &apos;计时.&apos;);
            }
        });
    }
};
</code></pre><p>看到了get请求！<br>尝试着拼凑链接，试了几次，成功了！</p>
<pre><code>http://202.196.96.221/partyStudy/Main/Services/ConditionService.ashx?method=SaveLearnTime&amp;&amp;learnTime=8000
</code></pre><p>8000为秒数，直接提交请求即可，即为学习了8000秒，然后不要点击保存学习时间，直接返回首页，再进去时学习时间已经够了<br>之后是章节测试<br>用同样的方法，查看了下页面的js，发现测试分数是在服务器计算的，这就没有办法了</p>
<p>虽然学习系统是有漏洞的，但还是要认真学习下内容，不能偷懒啊</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;学校让在线学习党课内容，想到之前学校的四六级报名系统就存在太多安全问题，可以下载全校的免冠照片，尝试着破解了一下党课学习系统&lt;br&gt;学习系统是要在网页中浏览指定的时间后才可以进行测试，一个章节有两个小时，有几十分钟的，并且每隔五分钟不移动鼠标就停止计时&lt;br&gt;将网页保存到本地后，发现了名为LearnControl.js的javascrip文件，找到了如下的一段代码&lt;/p&gt;
    
    </summary>
    
      <category term="Tech" scheme="http://mjackie.github.io/categories/Tech/"/>
    
    
      <category term="javascript" scheme="http://mjackie.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>PHP Session实现用户登陆功能</title>
    <link href="http://mjackie.github.io/Tech/cj6nko880000g6l5kry8su3b8/"/>
    <id>http://mjackie.github.io/Tech/cj6nko880000g6l5kry8su3b8/</id>
    <published>2016-04-07T15:35:00.000Z</published>
    <updated>2017-08-15T13:19:57.928Z</updated>
    
    <content type="html"><![CDATA[<p>Session 是存储在服务器端的会话，相对安全，并且不像 Cookie 那样有存储长度限制.由于 Session 是以文本文件形式存储在服务器端的，所以不怕客户端修改 Session 内容。实际上在服务器端的 Session 文件，PHP 自动修改 Session 文件的权限，只保留了系统读和写权限，而且不能通过 ftp 修改，所以安全得多。</p>
<a id="more"></a>
<p>login.php</p>
<pre><code>&lt;?php
//  表单提交后...
$posts = $_POST;
//  清除一些空白符号
foreach ($posts as $key =&gt; $value) {
    $posts[$key] = trim($value);
}
$password = md5($posts[&quot;password&quot;]);
$username = $posts[&quot;username&quot;]; 

$query = &quot;SELECT `username` FROM `user` WHERE `password` = &apos;$password&apos; AND `username` = &apos;$username&apos;&quot;;
//  取得查询结果
$userInfo = $DB-&gt;getRow($query); 

if (!empty($userInfo)) {
    //  当验证通过后，启动 Session
    session_start();
    //  注册登陆成功的 admin 变量，并赋值 true
    $_SESSION[&quot;admin&quot;] = true;
} else {
    die(&quot;用户名密码错误&quot;);
}
?&gt;
</code></pre><p>check.php</p>
<pre><code>&lt;?php
//  防止全局变量造成安全隐患
$admin = false;
//  启动会话，这步必不可少
session_start();
//  判断是否登陆
if (isset($_SESSION[&quot;admin&quot;]) &amp;&amp; $_SESSION[&quot;admin&quot;] === true) {
    echo &quot;您已经成功登陆&quot;;
} else {
    //  验证失败，将 $_SESSION[&quot;admin&quot;] 置为 false
    $_SESSION[&quot;admin&quot;] = false;
    die(&quot;您无权访问&quot;);
}
?&gt;
</code></pre><p>exit.php</p>
<pre><code>&lt;?php
session_start();
//  这种方法是将原来注册的某个变量销毁
unset($_SESSION[&apos;admin&apos;]);
//  这种方法是销毁整个 Session 文件
session_destroy();
?&gt;
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Session 是存储在服务器端的会话，相对安全，并且不像 Cookie 那样有存储长度限制.由于 Session 是以文本文件形式存储在服务器端的，所以不怕客户端修改 Session 内容。实际上在服务器端的 Session 文件，PHP 自动修改 Session 文件的权限，只保留了系统读和写权限，而且不能通过 ftp 修改，所以安全得多。&lt;/p&gt;
    
    </summary>
    
      <category term="Tech" scheme="http://mjackie.github.io/categories/Tech/"/>
    
    
      <category term="php" scheme="http://mjackie.github.io/tags/php/"/>
    
  </entry>
  
  <entry>
    <title>姿态测算原理</title>
    <link href="http://mjackie.github.io/Tech/cj6nko89w00206l5kaib4afi4/"/>
    <id>http://mjackie.github.io/Tech/cj6nko89w00206l5kaib4afi4/</id>
    <published>2016-04-04T14:03:00.000Z</published>
    <updated>2016-11-25T14:37:03.647Z</updated>
    
    <content type="html"><![CDATA[<p>经过信号预处理（滤波、校准等），可得到精准传感器输出信号，进而为精确进行姿态测算提供保障。常用的载体姿态获取方法有：<br>（1）利用陀螺仪产生的角速度信号，积分求取三轴旋转角度，从而获得物体姿态变化，可用四元数表示；<br>（2）利用加速度计产生的重力加速度信号和磁力计产生的地磁信号，可分别得到载体航向家、横滚角及航向角，从而得到物体姿态；可通过转换以四元数表示；<br>（3）多个系统捷联组合进行姿态测算，如通过卡尔曼融合算法，将陀螺仪、加速度计和磁力计产生的信号进行合理融合，角速度信号对动态情况下的物体姿态测算优势明显，而加速度与磁力计可对角速度信号的测算进行不定时修正，从而实现传感器之间的互补，使姿态测算更加精确、更适用于各种环境。<br>由于陀螺仪存在零偏及长时间使用后信号漂移等现象，如利用第一种方法进行姿态测算，姿态误差会随时间的推移而不断增大，从而导致无法长期稳定的精确信号输出；加速度计及磁力计皆利用地球本身存在的稳定的外部因素产生输出信号，更容易获得物体的绝对姿态，然而在运动过程中，物体同样会产生加速度，对姿态测算造成干扰，而磁力计也易受磁性物质干扰，因此第二种方法适合物体本身运动幅度较小的情况，不利于在物体快速运动时的姿态测算，即动态性能不好。第三种方法对前两种方法进行融合，能够分别发挥两种方法的优势，虽然采用卡尔曼滤波等信息融合技术，增加了运算量，但能在各种运动情况下获取物体精确姿态，是目前捷联导航系统中最常用的姿态测算方法。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;经过信号预处理（滤波、校准等），可得到精准传感器输出信号，进而为精确进行姿态测算提供保障。常用的载体姿态获取方法有：&lt;br&gt;（1）利用陀螺仪产生的角速度信号，积分求取三轴旋转角度，从而获得物体姿态变化，可用四元数表示；&lt;br&gt;（2）利用加速度计产生的重力加速度信号和磁力计产
    
    </summary>
    
      <category term="Tech" scheme="http://mjackie.github.io/categories/Tech/"/>
    
    
  </entry>
  
  <entry>
    <title>keybd_event函数</title>
    <link href="http://mjackie.github.io/Tech/cj6nko89b001f6l5kds1kd3x9/"/>
    <id>http://mjackie.github.io/Tech/cj6nko89b001f6l5kds1kd3x9/</id>
    <published>2016-03-30T05:53:00.000Z</published>
    <updated>2017-07-31T11:30:44.343Z</updated>
    
    <content type="html"><![CDATA[<p>keybd_event函数，系统可使用这种合成的击键事件来产生WM_KEYUP或WM_KEYDOWN消息。<br>函数原型；void keybd_event(BYTE bVk，BYTE bScan，DWORD dwFlags，DWORD dwExtralnfo);<br>包含4个参数：<br>  第一个为按键的虚拟键值，如回车键为vk_return, tab键为vk_tab（其他具体的参见附录：常用模拟键的键值对照表）；<br>  第二个参数为扫描码，一般不用设置，用0代替就行；<br>  第三个参数为选项标志，如果为keydown则置0即可，如果为keyup则设成”KEYEVENTF_KEYUP”；<br>  第四个参数一般也是置0即可。</p>
<pre><code>//模拟按下&apos;ALT+F4&apos;键
keybd_event(18,0,0,0);
keybd_event(115,0,0,0);
keybd_event(115,0,KEYEVENTF_KEYUP,0);
keybd_event(18,0,KEYEVENTF_KEYUP,0);
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;keybd_event函数，系统可使用这种合成的击键事件来产生WM_KEYUP或WM_KEYDOWN消息。&lt;br&gt;函数原型；void keybd_event(BYTE bVk，BYTE bScan，DWORD dwFlags，DWORD dwExtralnfo);&lt;br&gt;包
    
    </summary>
    
      <category term="Tech" scheme="http://mjackie.github.io/categories/Tech/"/>
    
    
      <category term="c++" scheme="http://mjackie.github.io/tags/c/"/>
    
      <category term="c" scheme="http://mjackie.github.io/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>姿态角</title>
    <link href="http://mjackie.github.io/Tech/cj6nko8a000266l5kxsggabw9/"/>
    <id>http://mjackie.github.io/Tech/cj6nko8a000266l5kxsggabw9/</id>
    <published>2016-03-28T15:17:00.000Z</published>
    <updated>2017-08-01T07:17:33.725Z</updated>
    
    <content type="html"><![CDATA[<p>载体的姿态是载体坐标系在地理坐标系的表示，常用航向角、俯仰角和横滚角作为载体的姿态角。基于地理坐标系及载体坐标系，可得出姿态角的定义：</p>
<p><img src="/post_image/zitaijiao/zitaijiao1.gif" alt="image"><br>航向角：载体的x b 轴在水平面的投影与地磁北极夹角，叫做航向角，其表示范围为 0～360°；<br><a id="more"></a></p>
<hr>
<p><img src="/post_image/zitaijiao/zitaijiao2.gif" alt="image"><br>俯仰角：载体的x b 轴在当地水平面的投影与x b 间的夹角，叫做俯仰角，范围为-90～90°；</p>
<hr>
<p><img src="/post_image/zitaijiao/zitaijiao3.gif" alt="image"><br>横滚角：载体的y b 轴与其在当地水平面的投影间的夹角，叫做横滚角，范围为-180～180°。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;载体的姿态是载体坐标系在地理坐标系的表示，常用航向角、俯仰角和横滚角作为载体的姿态角。基于地理坐标系及载体坐标系，可得出姿态角的定义：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/post_image/zitaijiao/zitaijiao1.gif&quot; alt=&quot;image&quot;&gt;&lt;br&gt;航向角：载体的x b 轴在水平面的投影与地磁北极夹角，叫做航向角，其表示范围为 0～360°；&lt;br&gt;
    
    </summary>
    
      <category term="Tech" scheme="http://mjackie.github.io/categories/Tech/"/>
    
    
  </entry>
  
</feed>
